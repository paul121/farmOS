{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"farmOS 2.x \u00b6 ATTENTION: This documentation is for the UNSTABLE 2.x branch of farmOS, which is under active development. If you want to use farmOS, the recommended stable branch is 7.x-1.x. Current documentation for 7.x-1.x is available at http://farmOS.org .","title":"farmOS 2.x"},{"location":"#farmos-2x","text":"ATTENTION: This documentation is for the UNSTABLE 2.x branch of farmOS, which is under active development. If you want to use farmOS, the recommended stable branch is 7.x-1.x. Current documentation for 7.x-1.x is available at http://farmOS.org .","title":"farmOS 2.x"},{"location":"development/api/","text":"API \u00b6 farmOS provides an API that other applications/systems can use to read and write records via HTTP requests. The root API endpoint is /api . farmOS adheres to the JSON:API specification, and JSON Schema is used to describe the available API resources. To begin exploring the farmOS API schema, visit /api/schema . From there, you can traverse a graph of interconnected schemas describing the entire API.","title":"Introduction"},{"location":"development/api/#api","text":"farmOS provides an API that other applications/systems can use to read and write records via HTTP requests. The root API endpoint is /api . farmOS adheres to the JSON:API specification, and JSON Schema is used to describe the available API resources. To begin exploring the farmOS API schema, visit /api/schema . From there, you can traverse a graph of interconnected schemas describing the entire API.","title":"API"},{"location":"development/api/authentication/","text":"Authentication \u00b6 farmOS includes an OAuth2 Authorization server for providing 1st and 3rd party clients access to the farmOS API. Rather than using a user's username and password to both authorize and authenticate a request, OAuth2 requires users to complete an authorization flow that generates an access_token to be used for authentication. Access tokens are provided to both 1st and 3rd party clients who wish to access the server's protected resources. Clients store the access token instead of the user's credentials, which makes it a more secure authentication method. Read more about the OAuth 2.0 standards . Client Libraries \u00b6 The farmOS.py and farmOS.js client libraries use the OAuth2 protocol to interact with the farmOS API. OAuth2 Bearer Tokens \u00b6 Once you have an OAuth2 token, you can authenticate requests to the farmOS server by including an Authentication: Bearer {access_token} header. OAuth2 Details \u00b6 The OAuth protocol defines a process where users authorize 1st and 3rd party clients with scoped access to data on the server. The following describes the details necessary for using OAuth2 authorization with a farmOS server. Scopes \u00b6 OAuth Scopes define different levels of permission. The farmOS server implements scopes as roles associated with OAuth clients. This means that users will authorize clients with roles that determine how much access they have to data on the server. Clients \u00b6 An OAuth Client represents a 1st or 3rd party integration with the farmOS server. Clients are uniquely identified by a client_id and are configured to use different scopes . The core farm_api module provides a default client with client_id = farm . If you are writing a script that communicates with your farmOS server via the API, you should use this client to authorize access and generate an access_token for authentication. If you are creating a third party integration with farmOS, see the OAuth page of the farmOS module development docs for steps to create an OAuth Client. Authorization Flows \u00b6 The OAuth 2.0 standards outline 5 Oauth2 Grant Types to be used in an OAuth2 Authorization Flow - They are the Authorization Code, Implicit, Password Credentials, Client Credentials and Refresh Token Grants. The Authorization Code and Refresh Token grants are the only Authorization Flows recommended by farmOS for use with 3rd party clients. NOTE: Only use the Password Grant if the client can be trusted with a farmOS username and password (this is considered 1st party ). The Client Credentials Grant is often used for machine authentication not associated with a user account. The client credentials grant should only be used if a client_secret can be kept secret. If connecting to multiple farmOS servers, each server should use a different secret. This is challenging due to the nature of farmOS being a self-hosted application. Authorization Code Grant \u00b6 The Authorization Code Grant is most popular for 3rd party client authorization. Requesting resources is a four step process: First : the client sends a request to the farmOS server /oauth/authorize endpoint requesting an Authorization Code . The user logs in and authorizes the client to have the OAuth Scopes it is requesting. Copy this link to browser - http://localhost/oauth/authorize?response_type=code&client_id=farmos_development&scope=user_access&redirect_uri=http://localhost/api/authorized&state=p4W8P5f7gJCIDbC1Mv78zHhlpJOidy Second : after the user accepts, the server redirects to the redirect_uri with an authorization code and state in the query parameters. Example redirect url from server: http://localhost/api/authorized?code=9eb9442c7a2b011fd59617635cca5421cd089943&state=p4W8P5f7gJCIDbC1Mv78zHhlpJOidy Third : copy the code and state from the URL into the body of a POST request. The grant_type , client_id , client_secret and redirect_uri must also be included in the POST body. The client makes a POST request to the /oauth/token endpoint to retrieve an access_token and refresh_token . foo@bar:~$ curl -X POST -d \"grant_type=authorization_code&code=ae4d1381cc67def1c10dc88a19af6ac30d7b5959&client_id=farmos_development&redirect_uri=http://localhost/api/authorized\" http://localhost/oauth/token {\"access_token\":\"3f9212c4a6656f1cd1304e47307927a7c224abb0\",\"expires_in\":\"10\",\"token_type\":\"Bearer\",\"scope\":\"user_access\",\"refresh_token\":\"292810b04d688bfb5c3cee28e45637ec8ef1dd9e\"} Fourth : the client sends the access token in the request header to access protected resources. The header is an Authorization header with a Bearer token: Authorization: Bearer access_token foo@bar:~$ curl --header \"Authorization: Bearer b872daf5827a75495c8194c6bfa4f90cf46c143e\" http://localhost/farm.json {\"name\":\"farmos-server\",\"url\":\"http:\\/\\/localhost\",\"api_version\":\"1.1\",\"user\":{\"uid\":\"1\",\"name\":\"admin\", .... Password Credentials Grant \u00b6 NOTE: Only use the Password Grant if the client can be trusted with a farmOS username and password (this is considered 1st party ). The Password Credentials Grant uses a farmOS username and password to retrieve an access_token and refresh_token in one step. For the user, this is the simplest type of authorization. Because the client can be trusted with their farmOS Credentials, a users username and password can be collected directly into a login form within the client application. These credentials are then used (not stored) to request tokens which are used for authentication with the farmOS server and retrieving data. Requesting protected resources is a two step process: First , the client sends a POST request to the farmOS server /oauth/token endpoint with grant_type set to password and a username and password included in the request body. $ curl -X POST -d \"grant_type=password&username=username&password=test&client_id=farm&scope=user_access\" http://localhost/oauth/token {\"access_token\":\"e69c60dea3f5c59c95863928fa6fb860d3506fe9\",\"expires_in\":\"300\",\"token_type\":\"Bearer\",\"scope\":\"user_access\",\"refresh_token\":\"cead7d46d18d74daea83f114bc0b512ec4cc31c3\"} second , the client sends the access_token in the request header to access protected resources. The header is an Authorization header with a Bearer token: Authorization: Bearer access_token foo@bar:~$ curl --header \"Authorization: Bearer e69c60dea3f5c59c95863928fa6fb860d3506fe9\" http://localhost/farm.json {\"name\":\"farmos-server\",\"url\":\"http:\\/\\/localhost\",\"api_version\":\"1.1\",\"user\":{\"uid\":\"1\",\"name\":\"admin\", .... Refreshing Tokens \u00b6 The refresh_token can be used to retrieve a new access_token if the token has expired. It is a one step process: The client sends an authenticated request to the /oauth/token endpoint with grant_type set to refresh_token and includes the refresh_token , client_id and client_secret in the request body. foo@bar:~$ curl -X POST -H 'Authorization: Bearer ad52c04d26c1002084501d28b59196996f0bd93f' -d 'refresh_token=52e7a0e12e8ddd08b155b3b3ee385687fef01664&grant_type=refresh_token&client_id=farmos_api_client&client_secret=client_secret' http://localhost/oauth/token {\"access_token\":\"acdbfabb736e42aa301b50fdda95d6b7fd3e7e14\",\"expires_in\":\"300\",\"token_type\":\"Bearer\",\"scope\":\"user_access\",\"refresh_token\":\"b73f4744840498a26f43447d8cf755238bfd391a\"} The server responds with an access_token and refresh_token that can be used in future requests. The previous access_token and refresh_token will no longer work.","title":"Authentication"},{"location":"development/api/authentication/#authentication","text":"farmOS includes an OAuth2 Authorization server for providing 1st and 3rd party clients access to the farmOS API. Rather than using a user's username and password to both authorize and authenticate a request, OAuth2 requires users to complete an authorization flow that generates an access_token to be used for authentication. Access tokens are provided to both 1st and 3rd party clients who wish to access the server's protected resources. Clients store the access token instead of the user's credentials, which makes it a more secure authentication method. Read more about the OAuth 2.0 standards .","title":"Authentication"},{"location":"development/api/authentication/#client-libraries","text":"The farmOS.py and farmOS.js client libraries use the OAuth2 protocol to interact with the farmOS API.","title":"Client Libraries"},{"location":"development/api/authentication/#oauth2-bearer-tokens","text":"Once you have an OAuth2 token, you can authenticate requests to the farmOS server by including an Authentication: Bearer {access_token} header.","title":"OAuth2 Bearer Tokens"},{"location":"development/api/authentication/#oauth2-details","text":"The OAuth protocol defines a process where users authorize 1st and 3rd party clients with scoped access to data on the server. The following describes the details necessary for using OAuth2 authorization with a farmOS server.","title":"OAuth2 Details"},{"location":"development/api/authentication/#scopes","text":"OAuth Scopes define different levels of permission. The farmOS server implements scopes as roles associated with OAuth clients. This means that users will authorize clients with roles that determine how much access they have to data on the server.","title":"Scopes"},{"location":"development/api/authentication/#clients","text":"An OAuth Client represents a 1st or 3rd party integration with the farmOS server. Clients are uniquely identified by a client_id and are configured to use different scopes . The core farm_api module provides a default client with client_id = farm . If you are writing a script that communicates with your farmOS server via the API, you should use this client to authorize access and generate an access_token for authentication. If you are creating a third party integration with farmOS, see the OAuth page of the farmOS module development docs for steps to create an OAuth Client.","title":"Clients"},{"location":"development/api/authentication/#authorization-flows","text":"The OAuth 2.0 standards outline 5 Oauth2 Grant Types to be used in an OAuth2 Authorization Flow - They are the Authorization Code, Implicit, Password Credentials, Client Credentials and Refresh Token Grants. The Authorization Code and Refresh Token grants are the only Authorization Flows recommended by farmOS for use with 3rd party clients. NOTE: Only use the Password Grant if the client can be trusted with a farmOS username and password (this is considered 1st party ). The Client Credentials Grant is often used for machine authentication not associated with a user account. The client credentials grant should only be used if a client_secret can be kept secret. If connecting to multiple farmOS servers, each server should use a different secret. This is challenging due to the nature of farmOS being a self-hosted application.","title":"Authorization Flows"},{"location":"development/api/authentication/#authorization-code-grant","text":"The Authorization Code Grant is most popular for 3rd party client authorization. Requesting resources is a four step process: First : the client sends a request to the farmOS server /oauth/authorize endpoint requesting an Authorization Code . The user logs in and authorizes the client to have the OAuth Scopes it is requesting. Copy this link to browser - http://localhost/oauth/authorize?response_type=code&client_id=farmos_development&scope=user_access&redirect_uri=http://localhost/api/authorized&state=p4W8P5f7gJCIDbC1Mv78zHhlpJOidy Second : after the user accepts, the server redirects to the redirect_uri with an authorization code and state in the query parameters. Example redirect url from server: http://localhost/api/authorized?code=9eb9442c7a2b011fd59617635cca5421cd089943&state=p4W8P5f7gJCIDbC1Mv78zHhlpJOidy Third : copy the code and state from the URL into the body of a POST request. The grant_type , client_id , client_secret and redirect_uri must also be included in the POST body. The client makes a POST request to the /oauth/token endpoint to retrieve an access_token and refresh_token . foo@bar:~$ curl -X POST -d \"grant_type=authorization_code&code=ae4d1381cc67def1c10dc88a19af6ac30d7b5959&client_id=farmos_development&redirect_uri=http://localhost/api/authorized\" http://localhost/oauth/token {\"access_token\":\"3f9212c4a6656f1cd1304e47307927a7c224abb0\",\"expires_in\":\"10\",\"token_type\":\"Bearer\",\"scope\":\"user_access\",\"refresh_token\":\"292810b04d688bfb5c3cee28e45637ec8ef1dd9e\"} Fourth : the client sends the access token in the request header to access protected resources. The header is an Authorization header with a Bearer token: Authorization: Bearer access_token foo@bar:~$ curl --header \"Authorization: Bearer b872daf5827a75495c8194c6bfa4f90cf46c143e\" http://localhost/farm.json {\"name\":\"farmos-server\",\"url\":\"http:\\/\\/localhost\",\"api_version\":\"1.1\",\"user\":{\"uid\":\"1\",\"name\":\"admin\", ....","title":"Authorization Code Grant"},{"location":"development/api/authentication/#password-credentials-grant","text":"NOTE: Only use the Password Grant if the client can be trusted with a farmOS username and password (this is considered 1st party ). The Password Credentials Grant uses a farmOS username and password to retrieve an access_token and refresh_token in one step. For the user, this is the simplest type of authorization. Because the client can be trusted with their farmOS Credentials, a users username and password can be collected directly into a login form within the client application. These credentials are then used (not stored) to request tokens which are used for authentication with the farmOS server and retrieving data. Requesting protected resources is a two step process: First , the client sends a POST request to the farmOS server /oauth/token endpoint with grant_type set to password and a username and password included in the request body. $ curl -X POST -d \"grant_type=password&username=username&password=test&client_id=farm&scope=user_access\" http://localhost/oauth/token {\"access_token\":\"e69c60dea3f5c59c95863928fa6fb860d3506fe9\",\"expires_in\":\"300\",\"token_type\":\"Bearer\",\"scope\":\"user_access\",\"refresh_token\":\"cead7d46d18d74daea83f114bc0b512ec4cc31c3\"} second , the client sends the access_token in the request header to access protected resources. The header is an Authorization header with a Bearer token: Authorization: Bearer access_token foo@bar:~$ curl --header \"Authorization: Bearer e69c60dea3f5c59c95863928fa6fb860d3506fe9\" http://localhost/farm.json {\"name\":\"farmos-server\",\"url\":\"http:\\/\\/localhost\",\"api_version\":\"1.1\",\"user\":{\"uid\":\"1\",\"name\":\"admin\", ....","title":"Password Credentials Grant"},{"location":"development/api/authentication/#refreshing-tokens","text":"The refresh_token can be used to retrieve a new access_token if the token has expired. It is a one step process: The client sends an authenticated request to the /oauth/token endpoint with grant_type set to refresh_token and includes the refresh_token , client_id and client_secret in the request body. foo@bar:~$ curl -X POST -H 'Authorization: Bearer ad52c04d26c1002084501d28b59196996f0bd93f' -d 'refresh_token=52e7a0e12e8ddd08b155b3b3ee385687fef01664&grant_type=refresh_token&client_id=farmos_api_client&client_secret=client_secret' http://localhost/oauth/token {\"access_token\":\"acdbfabb736e42aa301b50fdda95d6b7fd3e7e14\",\"expires_in\":\"300\",\"token_type\":\"Bearer\",\"scope\":\"user_access\",\"refresh_token\":\"b73f4744840498a26f43447d8cf755238bfd391a\"} The server responds with an access_token and refresh_token that can be used in future requests. The previous access_token and refresh_token will no longer work.","title":"Refreshing Tokens"},{"location":"development/api/changes/","text":"API Changes \u00b6 2.x vs 1.x \u00b6 farmOS 1.x used the RESTful Web Services module, which provided API endpoints for each entity type (asset, log, taxonomy term, etc). farmOS 2.x uses the new JSON:API module included with Drupal core, which follows the JSON:API specification for defining API resources. The root API endpoint is /api . JSON Schema \u00b6 farmOS 2.x also provides JSON Schema information about all available resources. The root endpoint for schema information is /api/schema . In farmOS 1.x, the /farm.json endpoint provided similar information in the resources property. This has been removed in favor of JSON Schema. Farm info endpoint \u00b6 In farmOS 1.x, an informational API endpoint was provided at /farm.json . This included various information describing the farmOS server configuration, authenticated user, installed languages and available entity types and bundles. This information was provided as either a simple value or a JSON object: { \"name\": \"My Farm\", \"url\": \"https://myfarm.mydomain.com\", \"api_version\": \"1.0\", \"system_of_measurement\": \"metric\", \"user\": { ... }, \"languages\": { ... }, \"resources\": { ... }, \"metrics\": { ... } } In farmOS 2.x, a root /api endpoint either provides this information, or is a gateway to this information. The simple values previously available from /farm.json are now provided in the meta.farm object at /api : { \"jsonapi\":{ ... }, \"data\":[], \"meta\":{ \"links\":{ \"me\":{ \"meta\":{ \"id\":\"7b2af019-3191-40ca-b221-616f9a365722\" }, \"href\":\"http://localhost/api/user/user/7b2af019-3191-40ca-b221-616f9a365722\" } }, \"farm\":{ \"name\":\"My farm name\", \"url\":\"http://localhost\", \"version\":\"2.x\", \"system_of_measurement\": \"metric\" } }, \"links\":{ ... } } The resources object has been replaced with the links object that describes all the available resource types and their endpoints. Information previously provided in the other JSON objects are now available as standalone resources at their respective endpoints: user - /api/user/user The authenticated user's ID is included in the meta.links.me object with a link to the user's resource. The user's attributes, such as name and language, can be retrieved from that endpoint. languages - /api/configurable_language/configurable_language Resource endpoints \u00b6 In farmOS 1.x, API endpoints for each entity type were available at /[entity_type].json . For example: /log.json In farmOS 2.x, a root /api endpoint is provided, with a links object that describes all the available resource types and their endpoints. These follow a URL pattern of /api/[entity-type]/[bundle] . For example: /api/log/activity \"Bundles\" are \"sub-types\" that can have different sets (bundles) of fields on them. For example, a \"Seeding Log\" and a \"Harvest Log\" will collect different information, but both are \"Logs\" (events). To illustrate the difference between 1.x and 2.x, here are the endpoints for retrieving all Activity logs. farmOS 1.x: /log.json?type=farm_activity farmOS 2.x: /api/log/activity IDs \u00b6 farmOS 2.x assigns UUIDs (universally unique identifiers) to all resources, and uses them in the API. This differs from farmOS 1.x, which used the integer IDs directly from the auto-incrementing database table that the record was pulled from. The benefit of UUIDs is they are guaranteed to be unique across multiple farmOS databases, whereas the old IDs were not. The internal integer IDs are not exposed via the API, so all code that needs to integrate should use the new UUIDs instead. Also note that the migration from farmOS 1.x to 2.x does not preserve the internal integer IDs, so they may be different after migrating to 2.x. Record structure \u00b6 JSON:API has some rules about how records are structured that differ from farmOS 1.x. These rules make the API more explicit. In farmOS 1.x, all the fields/properties of a record were on the same level. For example, a simple observation log looked like this: { \"id\": \"5\" \"type\": \"farm_observation\", \"name\": \"Test observation\", \"timestamp\": \"1526584271\", \"asset\": [ { \"resource\": \"farm_asset\", \"id\": \"123\" } ] } In farmOS 2.x, JSON:API dictates that the \"attributes\" and \"relationships\" of a record be explicitly declared under attributes and relationships properties in the JSON. The same record in farmOS 2.x looks like: { \"id\": \"9bc49ffd-76e8-4f86-b811-b721cb771327\" \"type\": \"log--observation\", \"attributes\": { \"name\": \"Test observation\", \"timestamp\": \"1526584271\", }, \"relationships\": { \"asset\": { \"data\": [ { \"type\": \"asset--animal\", \"id\": \"75116e3e-c45e-431d-8b58-1fce6bb315cf\", } ] } } } Filtering \u00b6 The URL query parameters for filtering results have a different syntax in 2.x. Refer to the Drupal.org JSON:API Filtering documentation for more information. To illustrate, this is how to filter activity logs by their completed status: farmOS 1.x: /log.json?type=activity&done=1 farmOS 2.x: /api/log/activity?filter[status]=complete Text format \u00b6 Long text fields (like notes ) include value and format sub-properties, where value is the text value, and format is the \"Text format\" to use when displaying the text. This is used to filter user-supplied text, to only allow certain HTML tags (filtering out potential XSS vulnerabilities), convert URLs to links, etc. This works the same in farmOS 2.x, but the default format has changed from farm_format to default . Logs \u00b6 Log types \u00b6 The farm_ prefix has been dropped from all log type names. For example, in farmOS 1.x an Activity log was farm_activity , and in farmOS 2.x it is simply activity . Additionally, the \"Soil test\" and \"Water test\" log types have been merged into a single \"Lab test\" log type. Below is the full list of log types in farmOS 1.x and their new names in 2.x: farm_activity -> activity farm_harvest -> harvest farm_input -> input farm_maintenance -> maintenance farm_medical -> medical farm_observation -> observation farm_purchase -> purchase farm_sale -> sale farm_seeding -> seeding farm_soil_test -> lab_test farm_transplanting -> transplanting farm_water_test -> lab_test Log fields \u00b6 Log field names are largely unchanged, with a few exceptions (note that new fields are not listed here): date_purchase -> purchase_date done -> status (see \"Log status\" below) files -> file flags -> flag geofield -> geometry images -> image input_method -> method input_source -> source log_category -> category log_owner -> owner seed_source -> source soil_lab -> lab water_lab -> lab See also \"Text format\" above for information about the changes to the format parameter of long text fields. Log status \u00b6 In farmOS 1.x, logs had a boolean property called done which was either 1 (done) or 0 (not done). In 2.x, the done property has changed to status , and can be set to either done or pending . Additional states may be added in the future. Assets \u00b6 Asset records in farmOS 1.x had an entity type of farm_asset . In farmOS 2.x, the farm_ prefix has been dropped. The entity type is now simply asset . Asset types \u00b6 Asset type names are largely unchanged, with one notable exception: the \"Planting\" asset type has been renamed to \"Plant\". Below is the full list of asset types in farmOS 1.x and their new names in 2.x: animal (unchanged) compost (unchanged) equipment (unchanged) group (unchanged) planting -> plant sensor (unchanged) Asset fields \u00b6 Asset field names are largely unchanged, with a few exceptions (note that new fields are not listed here): archived -> status and archived (see \"Asset status\" below) date -> birthdate (on animal assets) description -> notes (see also \"Text format\" above) flags -> flag files -> file images -> image animal_castrated -> castrated animal_nicknames -> nickname animal_sex -> sex animal_tag -> id_tag Asset status \u00b6 In farmOS 1.x, assets had a property called archived which was either 0 , which indicated that the asset was active, or a timestamp that recorded when the asset was archived. In farmOS 2.x, these have been split into two separate fields: status - The status of the asset (either active or archived ). archived - The timestamp when the asset was archived. This will be empty if the asset is active. Taxonomies \u00b6 farmOS 2.x continues to use Drupal's core taxonomy_term entities to represent vocabularies of terms. The vocabulary machine names have changed, to drop the farm_ prefix, and to standardize plurality. farm_log_categories -> log_category farm_materials -> material farm_season -> season","title":"Changes"},{"location":"development/api/changes/#api-changes","text":"","title":"API Changes"},{"location":"development/api/changes/#2x-vs-1x","text":"farmOS 1.x used the RESTful Web Services module, which provided API endpoints for each entity type (asset, log, taxonomy term, etc). farmOS 2.x uses the new JSON:API module included with Drupal core, which follows the JSON:API specification for defining API resources. The root API endpoint is /api .","title":"2.x vs 1.x"},{"location":"development/api/changes/#json-schema","text":"farmOS 2.x also provides JSON Schema information about all available resources. The root endpoint for schema information is /api/schema . In farmOS 1.x, the /farm.json endpoint provided similar information in the resources property. This has been removed in favor of JSON Schema.","title":"JSON Schema"},{"location":"development/api/changes/#farm-info-endpoint","text":"In farmOS 1.x, an informational API endpoint was provided at /farm.json . This included various information describing the farmOS server configuration, authenticated user, installed languages and available entity types and bundles. This information was provided as either a simple value or a JSON object: { \"name\": \"My Farm\", \"url\": \"https://myfarm.mydomain.com\", \"api_version\": \"1.0\", \"system_of_measurement\": \"metric\", \"user\": { ... }, \"languages\": { ... }, \"resources\": { ... }, \"metrics\": { ... } } In farmOS 2.x, a root /api endpoint either provides this information, or is a gateway to this information. The simple values previously available from /farm.json are now provided in the meta.farm object at /api : { \"jsonapi\":{ ... }, \"data\":[], \"meta\":{ \"links\":{ \"me\":{ \"meta\":{ \"id\":\"7b2af019-3191-40ca-b221-616f9a365722\" }, \"href\":\"http://localhost/api/user/user/7b2af019-3191-40ca-b221-616f9a365722\" } }, \"farm\":{ \"name\":\"My farm name\", \"url\":\"http://localhost\", \"version\":\"2.x\", \"system_of_measurement\": \"metric\" } }, \"links\":{ ... } } The resources object has been replaced with the links object that describes all the available resource types and their endpoints. Information previously provided in the other JSON objects are now available as standalone resources at their respective endpoints: user - /api/user/user The authenticated user's ID is included in the meta.links.me object with a link to the user's resource. The user's attributes, such as name and language, can be retrieved from that endpoint. languages - /api/configurable_language/configurable_language","title":"Farm info endpoint"},{"location":"development/api/changes/#resource-endpoints","text":"In farmOS 1.x, API endpoints for each entity type were available at /[entity_type].json . For example: /log.json In farmOS 2.x, a root /api endpoint is provided, with a links object that describes all the available resource types and their endpoints. These follow a URL pattern of /api/[entity-type]/[bundle] . For example: /api/log/activity \"Bundles\" are \"sub-types\" that can have different sets (bundles) of fields on them. For example, a \"Seeding Log\" and a \"Harvest Log\" will collect different information, but both are \"Logs\" (events). To illustrate the difference between 1.x and 2.x, here are the endpoints for retrieving all Activity logs. farmOS 1.x: /log.json?type=farm_activity farmOS 2.x: /api/log/activity","title":"Resource endpoints"},{"location":"development/api/changes/#ids","text":"farmOS 2.x assigns UUIDs (universally unique identifiers) to all resources, and uses them in the API. This differs from farmOS 1.x, which used the integer IDs directly from the auto-incrementing database table that the record was pulled from. The benefit of UUIDs is they are guaranteed to be unique across multiple farmOS databases, whereas the old IDs were not. The internal integer IDs are not exposed via the API, so all code that needs to integrate should use the new UUIDs instead. Also note that the migration from farmOS 1.x to 2.x does not preserve the internal integer IDs, so they may be different after migrating to 2.x.","title":"IDs"},{"location":"development/api/changes/#record-structure","text":"JSON:API has some rules about how records are structured that differ from farmOS 1.x. These rules make the API more explicit. In farmOS 1.x, all the fields/properties of a record were on the same level. For example, a simple observation log looked like this: { \"id\": \"5\" \"type\": \"farm_observation\", \"name\": \"Test observation\", \"timestamp\": \"1526584271\", \"asset\": [ { \"resource\": \"farm_asset\", \"id\": \"123\" } ] } In farmOS 2.x, JSON:API dictates that the \"attributes\" and \"relationships\" of a record be explicitly declared under attributes and relationships properties in the JSON. The same record in farmOS 2.x looks like: { \"id\": \"9bc49ffd-76e8-4f86-b811-b721cb771327\" \"type\": \"log--observation\", \"attributes\": { \"name\": \"Test observation\", \"timestamp\": \"1526584271\", }, \"relationships\": { \"asset\": { \"data\": [ { \"type\": \"asset--animal\", \"id\": \"75116e3e-c45e-431d-8b58-1fce6bb315cf\", } ] } } }","title":"Record structure"},{"location":"development/api/changes/#filtering","text":"The URL query parameters for filtering results have a different syntax in 2.x. Refer to the Drupal.org JSON:API Filtering documentation for more information. To illustrate, this is how to filter activity logs by their completed status: farmOS 1.x: /log.json?type=activity&done=1 farmOS 2.x: /api/log/activity?filter[status]=complete","title":"Filtering"},{"location":"development/api/changes/#text-format","text":"Long text fields (like notes ) include value and format sub-properties, where value is the text value, and format is the \"Text format\" to use when displaying the text. This is used to filter user-supplied text, to only allow certain HTML tags (filtering out potential XSS vulnerabilities), convert URLs to links, etc. This works the same in farmOS 2.x, but the default format has changed from farm_format to default .","title":"Text format"},{"location":"development/api/changes/#logs","text":"","title":"Logs"},{"location":"development/api/changes/#log-types","text":"The farm_ prefix has been dropped from all log type names. For example, in farmOS 1.x an Activity log was farm_activity , and in farmOS 2.x it is simply activity . Additionally, the \"Soil test\" and \"Water test\" log types have been merged into a single \"Lab test\" log type. Below is the full list of log types in farmOS 1.x and their new names in 2.x: farm_activity -> activity farm_harvest -> harvest farm_input -> input farm_maintenance -> maintenance farm_medical -> medical farm_observation -> observation farm_purchase -> purchase farm_sale -> sale farm_seeding -> seeding farm_soil_test -> lab_test farm_transplanting -> transplanting farm_water_test -> lab_test","title":"Log types"},{"location":"development/api/changes/#log-fields","text":"Log field names are largely unchanged, with a few exceptions (note that new fields are not listed here): date_purchase -> purchase_date done -> status (see \"Log status\" below) files -> file flags -> flag geofield -> geometry images -> image input_method -> method input_source -> source log_category -> category log_owner -> owner seed_source -> source soil_lab -> lab water_lab -> lab See also \"Text format\" above for information about the changes to the format parameter of long text fields.","title":"Log fields"},{"location":"development/api/changes/#log-status","text":"In farmOS 1.x, logs had a boolean property called done which was either 1 (done) or 0 (not done). In 2.x, the done property has changed to status , and can be set to either done or pending . Additional states may be added in the future.","title":"Log status"},{"location":"development/api/changes/#assets","text":"Asset records in farmOS 1.x had an entity type of farm_asset . In farmOS 2.x, the farm_ prefix has been dropped. The entity type is now simply asset .","title":"Assets"},{"location":"development/api/changes/#asset-types","text":"Asset type names are largely unchanged, with one notable exception: the \"Planting\" asset type has been renamed to \"Plant\". Below is the full list of asset types in farmOS 1.x and their new names in 2.x: animal (unchanged) compost (unchanged) equipment (unchanged) group (unchanged) planting -> plant sensor (unchanged)","title":"Asset types"},{"location":"development/api/changes/#asset-fields","text":"Asset field names are largely unchanged, with a few exceptions (note that new fields are not listed here): archived -> status and archived (see \"Asset status\" below) date -> birthdate (on animal assets) description -> notes (see also \"Text format\" above) flags -> flag files -> file images -> image animal_castrated -> castrated animal_nicknames -> nickname animal_sex -> sex animal_tag -> id_tag","title":"Asset fields"},{"location":"development/api/changes/#asset-status","text":"In farmOS 1.x, assets had a property called archived which was either 0 , which indicated that the asset was active, or a timestamp that recorded when the asset was archived. In farmOS 2.x, these have been split into two separate fields: status - The status of the asset (either active or archived ). archived - The timestamp when the asset was archived. This will be empty if the asset is active.","title":"Asset status"},{"location":"development/api/changes/#taxonomies","text":"farmOS 2.x continues to use Drupal's core taxonomy_term entities to represent vocabularies of terms. The vocabulary machine names have changed, to drop the farm_ prefix, and to standardize plurality. farm_log_categories -> log_category farm_materials -> material farm_season -> season","title":"Taxonomies"},{"location":"development/environment/","text":"Getting started \u00b6 Follow these instructions to set up a local farmOS development environment. The only requirements are Docker and Docker Compose . 1. Set up Docker containers \u00b6 Run the following commands to create a farmOS directory and set up Docker containers for farmOS and PostgreSQL: mkdir farmOS && cd farmOS curl https://raw.githubusercontent.com/farmOS/farmOS/2.x/docker/docker-compose.development.yml -o docker-compose.yml docker-compose up -d 2. Install farmOS \u00b6 Open http://localhost in a browser and install farmOS with the following database credentials: Database type: PostgreSQL Database name: farm Database user: farm Database password: farm Advanced options > Host: db 3. Develop \u00b6 Open the www directory in your favorite IDE. Optional \u00b6 Configure private filesystem \u00b6 In order to upload files, a private file path must be configured. The following line must be added to www/web/sites/default/settings.php : $settings['file_private_path'] = '/opt/drupal/web/sites/default/private/files'; Configure debugger \u00b6 See Debugging .","title":"Getting started"},{"location":"development/environment/#getting-started","text":"Follow these instructions to set up a local farmOS development environment. The only requirements are Docker and Docker Compose .","title":"Getting started"},{"location":"development/environment/#1-set-up-docker-containers","text":"Run the following commands to create a farmOS directory and set up Docker containers for farmOS and PostgreSQL: mkdir farmOS && cd farmOS curl https://raw.githubusercontent.com/farmOS/farmOS/2.x/docker/docker-compose.development.yml -o docker-compose.yml docker-compose up -d","title":"1. Set up Docker containers"},{"location":"development/environment/#2-install-farmos","text":"Open http://localhost in a browser and install farmOS with the following database credentials: Database type: PostgreSQL Database name: farm Database user: farm Database password: farm Advanced options > Host: db","title":"2. Install farmOS"},{"location":"development/environment/#3-develop","text":"Open the www directory in your favorite IDE.","title":"3. Develop"},{"location":"development/environment/#optional","text":"","title":"Optional"},{"location":"development/environment/#configure-private-filesystem","text":"In order to upload files, a private file path must be configured. The following line must be added to www/web/sites/default/settings.php : $settings['file_private_path'] = '/opt/drupal/web/sites/default/private/files';","title":"Configure private filesystem"},{"location":"development/environment/#configure-debugger","text":"See Debugging .","title":"Configure debugger"},{"location":"development/environment/code/","text":"Coding standards \u00b6 farmOS follows Drupal coding standards . The farmOS development Docker image comes pre-installed with PHP CodeSniffer for detecting code standard violations. The following command will run PHP CodeSniffer on all farmOS code: docker exec -it -u www-data farmos_www_1 phpcs /opt/drupal/web/profiles/farm If you see no output, then there are no issues. In some cases, code standard violations can be fixed automatically with phpcbf : docker exec -it -u www-data farmos_www_1 phpcbf /opt/drupal/web/profiles/farm","title":"Coding standards"},{"location":"development/environment/code/#coding-standards","text":"farmOS follows Drupal coding standards . The farmOS development Docker image comes pre-installed with PHP CodeSniffer for detecting code standard violations. The following command will run PHP CodeSniffer on all farmOS code: docker exec -it -u www-data farmos_www_1 phpcs /opt/drupal/web/profiles/farm If you see no output, then there are no issues. In some cases, code standard violations can be fixed automatically with phpcbf : docker exec -it -u www-data farmos_www_1 phpcbf /opt/drupal/web/profiles/farm","title":"Coding standards"},{"location":"development/environment/composer/","text":"Composer \u00b6 The farmOS development Docker image comes pre-installed with Composer , which is used for dependency management. Running Composer in Docker \u00b6 In order to run the composer command, you must use docker exec to run the command inside the farmOS container. docker exec -it -u www-data farmos_www_1 composer For example, the following will run the composer help command: docker exec -it -u www-data farmos_www_1 composer help' Warning : If composer update farmos/farmos is run, it will replace the Git repository in web/profiles/farm , discarding all changes/branches/remotes/etc. Common tasks \u00b6 Some common Composer tasks are documented here. Adding a module \u00b6 composer require drupal/[module] This will download the module into the web/modules/contrib directory, and add it to the root composer.json file. If the module is being added to the farmOS installation profile itself, you need to manually move the require line from the root composer.json to web/profiles/farm/composer.json and commit it to that repository. To install the module, use Drush . Notes \u00b6 Could not delete /var/www/html/web/sites/default/default.settings.php See https://www.drupal.org/docs/develop/using-composer/starting-a-site-using-drupal-composer-project-templates#s-troubleshooting-permission-issues-prevent-running-composer","title":"Composer"},{"location":"development/environment/composer/#composer","text":"The farmOS development Docker image comes pre-installed with Composer , which is used for dependency management.","title":"Composer"},{"location":"development/environment/composer/#running-composer-in-docker","text":"In order to run the composer command, you must use docker exec to run the command inside the farmOS container. docker exec -it -u www-data farmos_www_1 composer For example, the following will run the composer help command: docker exec -it -u www-data farmos_www_1 composer help' Warning : If composer update farmos/farmos is run, it will replace the Git repository in web/profiles/farm , discarding all changes/branches/remotes/etc.","title":"Running Composer in Docker"},{"location":"development/environment/composer/#common-tasks","text":"Some common Composer tasks are documented here.","title":"Common tasks"},{"location":"development/environment/composer/#adding-a-module","text":"composer require drupal/[module] This will download the module into the web/modules/contrib directory, and add it to the root composer.json file. If the module is being added to the farmOS installation profile itself, you need to manually move the require line from the root composer.json to web/profiles/farm/composer.json and commit it to that repository. To install the module, use Drush .","title":"Adding a module"},{"location":"development/environment/composer/#notes","text":"Could not delete /var/www/html/web/sites/default/default.settings.php See https://www.drupal.org/docs/develop/using-composer/starting-a-site-using-drupal-composer-project-templates#s-troubleshooting-permission-issues-prevent-running-composer","title":"Notes"},{"location":"development/environment/debug/","text":"Debugging \u00b6 The farmOS development Docker image comes pre-installed with XDebug 3, which allows debugger connections on port 9003. In order to connect to it, the XDEBUG_CONFIG environment variable must be used to configure XDebug's client_host setting with the Docker container's \"Gateway\" IP address. With the containers running, this command will print the gateway IP: docker inspect farmos_www_1 | grep -o '\"Gateway\": \".*\\..*\\..*\\..*\"' Edit docker-compose.yml and enter the gateway IP in the XDEBUG_CONFIG environment variable. For example: environment: XDEBUG_MODE: debug XDEBUG_CONFIG: client_host=192.168.128.1 Restart the Docker containers for this change to take affect. docker-compose restart Note : If the Docker containers are removed and recreated, the IP address may change, and you will need to repeat these steps to reconfigure it. PHPStorm \u00b6 If you are using the PHPStorm IDE, with the configuration above in place, enable the \"Start listening for PHP Debug Connections\" option. Add a breakpoint in your code, load the page in your browser, and you should see a prompt appear in PHPStorm that will begin the debugging session and pause execution at your breakpoint. Drush + PHPStorm \u00b6 Debugging code that is run via Drush commands requires additional configuration. Add an XDEBUG_SESSION environment variable with a value of PHPSTORM , and a PHP_IDE_CONFIG environment variable with a value of serverName=localhost , as follows: environment: XDEBUG_MODE: debug XDEBUG_CONFIG: client_host=192.168.128.1 XDEBUG_SESSION: PHPSTORM PHP_IDE_CONFIG: serverName=localhost Run a drush command and a prompt should appear in PHPStorm. You will need to map the path to Drush ( vendor/drush ) in the PHPStorm debugger config. Then you can set breakpoints in the Drush code you want to test.","title":"Debugging"},{"location":"development/environment/debug/#debugging","text":"The farmOS development Docker image comes pre-installed with XDebug 3, which allows debugger connections on port 9003. In order to connect to it, the XDEBUG_CONFIG environment variable must be used to configure XDebug's client_host setting with the Docker container's \"Gateway\" IP address. With the containers running, this command will print the gateway IP: docker inspect farmos_www_1 | grep -o '\"Gateway\": \".*\\..*\\..*\\..*\"' Edit docker-compose.yml and enter the gateway IP in the XDEBUG_CONFIG environment variable. For example: environment: XDEBUG_MODE: debug XDEBUG_CONFIG: client_host=192.168.128.1 Restart the Docker containers for this change to take affect. docker-compose restart Note : If the Docker containers are removed and recreated, the IP address may change, and you will need to repeat these steps to reconfigure it.","title":"Debugging"},{"location":"development/environment/debug/#phpstorm","text":"If you are using the PHPStorm IDE, with the configuration above in place, enable the \"Start listening for PHP Debug Connections\" option. Add a breakpoint in your code, load the page in your browser, and you should see a prompt appear in PHPStorm that will begin the debugging session and pause execution at your breakpoint.","title":"PHPStorm"},{"location":"development/environment/debug/#drush-phpstorm","text":"Debugging code that is run via Drush commands requires additional configuration. Add an XDEBUG_SESSION environment variable with a value of PHPSTORM , and a PHP_IDE_CONFIG environment variable with a value of serverName=localhost , as follows: environment: XDEBUG_MODE: debug XDEBUG_CONFIG: client_host=192.168.128.1 XDEBUG_SESSION: PHPSTORM PHP_IDE_CONFIG: serverName=localhost Run a drush command and a prompt should appear in PHPStorm. You will need to map the path to Drush ( vendor/drush ) in the PHPStorm debugger config. Then you can set breakpoints in the Drush code you want to test.","title":"Drush + PHPStorm"},{"location":"development/environment/docker/","text":"Docker \u00b6 Docker build arguments \u00b6 The farmOS Docker images allow certain variables to be overridden at image build time using the --build-arg parameter of docker build . Available arguments and their default values are described below: FARMOS_REPO - The farmOS Git repository URL. Default: https://github.com/farmOS/farmOS.git FARMOS_VERSION - The farmOS Git branch/tag/commit to check out. Default: 2.x PROJECT_REPO - The farmOS Composer project Git repository URL. Default: https://github.com/farmOS/composer-project.git PROJECT_VERSION - The farmOS Composer project Git branch/tag/commit to check out. Default: 2.x The 2.x-dev image also provides the following: WWW_DATA_ID - The ID to use for the www-data user and group inside the image. Setting this to the ID of the developer's user on the host machine allows Composer to create files owned by www-data inside the container, while keeping those files editable by the developer outside of the container. If your user ID is not 1000 , build the image with: --build-arg WWW_DATA_ID=$(id -u) Default: 1000","title":"Docker"},{"location":"development/environment/docker/#docker","text":"","title":"Docker"},{"location":"development/environment/docker/#docker-build-arguments","text":"The farmOS Docker images allow certain variables to be overridden at image build time using the --build-arg parameter of docker build . Available arguments and their default values are described below: FARMOS_REPO - The farmOS Git repository URL. Default: https://github.com/farmOS/farmOS.git FARMOS_VERSION - The farmOS Git branch/tag/commit to check out. Default: 2.x PROJECT_REPO - The farmOS Composer project Git repository URL. Default: https://github.com/farmOS/composer-project.git PROJECT_VERSION - The farmOS Composer project Git branch/tag/commit to check out. Default: 2.x The 2.x-dev image also provides the following: WWW_DATA_ID - The ID to use for the www-data user and group inside the image. Setting this to the ID of the developer's user on the host machine allows Composer to create files owned by www-data inside the container, while keeping those files editable by the developer outside of the container. If your user ID is not 1000 , build the image with: --build-arg WWW_DATA_ID=$(id -u) Default: 1000","title":"Docker build arguments"},{"location":"development/environment/documentation/","text":"Documentation \u00b6 In addition to the code for farmOS 2.x, this repository includes the source files of the documentation which is hosted at http://2x.farmos.org . It uses mkdocs to convert simple markdown files into static HTML files. To get started contributing to the farmOS 2.x documentation, fork farmOS on Github. Then install mkdocs and clone this repo: $ brew install python # For OSX users $ sudo apt-get install python-pip # For Debian/Ubuntu users $ sudo pip install mkdocs mkdocs-material $ git clone https://github.com/farmOS/farmOS.git farmOS $ cd farmOS $ git checkout 2.x $ git remote add sandbox git@github.com:<username>/farmOS.git $ mkdocs serve Your local farmOS 2.x documentation site should now be available for browsing: http://127.0.0.1:8000/. When you find a typo, an error, unclear or missing explanations or instructions, hit ctrl-c, to stop the server, and start editing. Find the page you\u2019d like to edit; everything is in the docs/ directory. Make your changes, commit and push them, and start a pull request: $ git checkout -b fix_typo # Create a new branch for your changes. ... # Make your changes. $ mkdocs build --clean; mkdocs serve # Go check your changes. $ git diff # Make sure there aren\u2019t any unintended changes. ... $ git commit -am \"Fixed typo.\" # Useful commit message are a good habit. $ git push sandbox fix_typo # Push your new branch up to your Github sandbox. Visit your fork on Github and start a Pull Request. For more information on writing and managing documentation with mkdocs, read the official mkdocs documentation: http://www.mkdocs.org","title":"Documentation"},{"location":"development/environment/documentation/#documentation","text":"In addition to the code for farmOS 2.x, this repository includes the source files of the documentation which is hosted at http://2x.farmos.org . It uses mkdocs to convert simple markdown files into static HTML files. To get started contributing to the farmOS 2.x documentation, fork farmOS on Github. Then install mkdocs and clone this repo: $ brew install python # For OSX users $ sudo apt-get install python-pip # For Debian/Ubuntu users $ sudo pip install mkdocs mkdocs-material $ git clone https://github.com/farmOS/farmOS.git farmOS $ cd farmOS $ git checkout 2.x $ git remote add sandbox git@github.com:<username>/farmOS.git $ mkdocs serve Your local farmOS 2.x documentation site should now be available for browsing: http://127.0.0.1:8000/. When you find a typo, an error, unclear or missing explanations or instructions, hit ctrl-c, to stop the server, and start editing. Find the page you\u2019d like to edit; everything is in the docs/ directory. Make your changes, commit and push them, and start a pull request: $ git checkout -b fix_typo # Create a new branch for your changes. ... # Make your changes. $ mkdocs build --clean; mkdocs serve # Go check your changes. $ git diff # Make sure there aren\u2019t any unintended changes. ... $ git commit -am \"Fixed typo.\" # Useful commit message are a good habit. $ git push sandbox fix_typo # Push your new branch up to your Github sandbox. Visit your fork on Github and start a Pull Request. For more information on writing and managing documentation with mkdocs, read the official mkdocs documentation: http://www.mkdocs.org","title":"Documentation"},{"location":"development/environment/drush/","text":"Drush \u00b6 The farmOS Docker image comes pre-installed with Drush , which provides shell commands for working with a Drupal installation. Running Drush in Docker \u00b6 In order to run the drush command, you must use docker exec to run the command inside the farmOS container. docker exec -it -u www-data farmos_www_1 drush For example, the following will run the drush cr command to rebuild caches: docker exec -it -u www-data farmos_www_1 drush cr Useful commands \u00b6 Some useful Drush commands are documented here. Rebuild caches \u00b6 drush cr Install a module \u00b6 drush en log","title":"Drush"},{"location":"development/environment/drush/#drush","text":"The farmOS Docker image comes pre-installed with Drush , which provides shell commands for working with a Drupal installation.","title":"Drush"},{"location":"development/environment/drush/#running-drush-in-docker","text":"In order to run the drush command, you must use docker exec to run the command inside the farmOS container. docker exec -it -u www-data farmos_www_1 drush For example, the following will run the drush cr command to rebuild caches: docker exec -it -u www-data farmos_www_1 drush cr","title":"Running Drush in Docker"},{"location":"development/environment/drush/#useful-commands","text":"Some useful Drush commands are documented here.","title":"Useful commands"},{"location":"development/environment/drush/#rebuild-caches","text":"drush cr","title":"Rebuild caches"},{"location":"development/environment/drush/#install-a-module","text":"drush en log","title":"Install a module"},{"location":"development/environment/postgresql/","text":"PostgreSQL \u00b6 The farmOS Docker image comes pre-installed with the PostgreSQL client psql command, which can be used to connect to the database and run queries from the command line. Open PostgreSQL prompt \u00b6 docker exec -it farmos_www_1 psql -h db -d farm -U farm Enter farm as the password.","title":"PostgreSQL"},{"location":"development/environment/postgresql/#postgresql","text":"The farmOS Docker image comes pre-installed with the PostgreSQL client psql command, which can be used to connect to the database and run queries from the command line.","title":"PostgreSQL"},{"location":"development/environment/postgresql/#open-postgresql-prompt","text":"docker exec -it farmos_www_1 psql -h db -d farm -U farm Enter farm as the password.","title":"Open PostgreSQL prompt"},{"location":"development/environment/tests/","text":"Automated tests \u00b6 The farmOS development Docker image comes pre-installed with all the dependencies necessary for running automated tests via PHPUnit . The following command will run all automated tests provided by farmOS: docker exec -it -u www-data farmos_www_1 phpunit --verbose --debug --group farm Tests from other projects/dependencies can be run in a similar fashion. For example, the following command will run all tests in the Log module: docker exec -it -u www-data farmos_www_1 phpunit --verbose --debug --group Log Faster testing without XDebug \u00b6 The instructions above will run tests with XDebug enabled which may be helpful for debugging , but is also slower. One way to avoid XDebug is to run the tests via the prod farmOS image. The automated tests which run upon Github check-in follow this strategy which is orchestrated via run-tests.yml and docker-compose.testing.yml . Something similar can be accomplished locally by adding an additional container to one's dev environment using the farmos/farmos:2.x image and mounting the same volume from the dev container to /opt/drupal . In a docker-compose.yml based off docker-compose.development.yml , this might look like; test-runner: image: farmos/farmos:2.x volumes: - './www:/opt/drupal' The tests could then be run via docker-compose exec as follows; docker-compose exec -u www-data -T test-runner phpunit --verbose --debug --group farm Note: As described in the farmOS docker documentation , the dev docker container uses a different user id for the www-data user - by default 1000. Since that id differs from the default www-data user id for the prod image - 33 - the permissions of the files mounted to /opt/drupal will cause tests to fail. Solutions to this will be specific to a developers environment, but some approaches are outlined below; Build a docker image derived from farmos/farmos:2.x which sets the id of the www-data user to match that of the dev image by including RUN usermod -u ${WWW_DATA_ID} www-data && groupmod -g ${WWW_DATA_ID} www-data and passing WWW_DATA_ID as a build build-arg Before launching the tests, use chmod / chown / setfacl to modify the permissions of the files mounted to /opt/drupal such that user id 33 can access them Rebuild the dev docker image to also use 33 as the user id of the www-data user","title":"Automated tests"},{"location":"development/environment/tests/#automated-tests","text":"The farmOS development Docker image comes pre-installed with all the dependencies necessary for running automated tests via PHPUnit . The following command will run all automated tests provided by farmOS: docker exec -it -u www-data farmos_www_1 phpunit --verbose --debug --group farm Tests from other projects/dependencies can be run in a similar fashion. For example, the following command will run all tests in the Log module: docker exec -it -u www-data farmos_www_1 phpunit --verbose --debug --group Log","title":"Automated tests"},{"location":"development/environment/tests/#faster-testing-without-xdebug","text":"The instructions above will run tests with XDebug enabled which may be helpful for debugging , but is also slower. One way to avoid XDebug is to run the tests via the prod farmOS image. The automated tests which run upon Github check-in follow this strategy which is orchestrated via run-tests.yml and docker-compose.testing.yml . Something similar can be accomplished locally by adding an additional container to one's dev environment using the farmos/farmos:2.x image and mounting the same volume from the dev container to /opt/drupal . In a docker-compose.yml based off docker-compose.development.yml , this might look like; test-runner: image: farmos/farmos:2.x volumes: - './www:/opt/drupal' The tests could then be run via docker-compose exec as follows; docker-compose exec -u www-data -T test-runner phpunit --verbose --debug --group farm Note: As described in the farmOS docker documentation , the dev docker container uses a different user id for the www-data user - by default 1000. Since that id differs from the default www-data user id for the prod image - 33 - the permissions of the files mounted to /opt/drupal will cause tests to fail. Solutions to this will be specific to a developers environment, but some approaches are outlined below; Build a docker image derived from farmos/farmos:2.x which sets the id of the www-data user to match that of the dev image by including RUN usermod -u ${WWW_DATA_ID} www-data && groupmod -g ${WWW_DATA_ID} www-data and passing WWW_DATA_ID as a build build-arg Before launching the tests, use chmod / chown / setfacl to modify the permissions of the files mounted to /opt/drupal such that user id 33 can access them Rebuild the dev docker image to also use 33 as the user id of the www-data user","title":"Faster testing without XDebug"},{"location":"development/environment/update/","text":"Updating local environment \u00b6 The following commands will update your local farmOS development environment. This approach avoids running composer commands because that is already done when the Docker image is built. Warning : This will replace everything except the profiles and sites directories. If you are developing farmOS core, this will ensure that your farmOS Git repository (inside profiles/farm ) will not be touched. If you are developing a custom module, make sure that it is in sites/all/modules , otherwise it will be deleted. PHPStorm : If you are using PHPStorm, you will also want to make sure the .idea folder is not destroyed during this process. If it is in the www directory, be sure to move that out before running rm -r www below, and restore it afterwards. It is recommended that you close PHPStorm during this process to avoid any project settings corruption. # Run these commands from the local directory that contains docker-compose.yml. # The Docker containers should be running. # Backup www volume, just in case. sudo tar -czf www.tar.gz www # Pull latest 2.x-dev Docker image. docker pull farmos/farmos:2.x-dev # Move directories. mv www/web/profiles ./profiles mv www/web/sites ./sites # Update codebase. docker-compose down rm -r www docker-compose up -d # Restore directories. sudo rm -rf www/web/profiles www/web/sites mv ./profiles www/web/profiles mv ./sites www/web/sites # Update farmOS profile. cd www/web/profiles/farm git checkout 2.x && git pull origin 2.x # Run Drupal database updates. docker-compose exec -u www-data www drush updb","title":"Updating"},{"location":"development/environment/update/#updating-local-environment","text":"The following commands will update your local farmOS development environment. This approach avoids running composer commands because that is already done when the Docker image is built. Warning : This will replace everything except the profiles and sites directories. If you are developing farmOS core, this will ensure that your farmOS Git repository (inside profiles/farm ) will not be touched. If you are developing a custom module, make sure that it is in sites/all/modules , otherwise it will be deleted. PHPStorm : If you are using PHPStorm, you will also want to make sure the .idea folder is not destroyed during this process. If it is in the www directory, be sure to move that out before running rm -r www below, and restore it afterwards. It is recommended that you close PHPStorm during this process to avoid any project settings corruption. # Run these commands from the local directory that contains docker-compose.yml. # The Docker containers should be running. # Backup www volume, just in case. sudo tar -czf www.tar.gz www # Pull latest 2.x-dev Docker image. docker pull farmos/farmos:2.x-dev # Move directories. mv www/web/profiles ./profiles mv www/web/sites ./sites # Update codebase. docker-compose down rm -r www docker-compose up -d # Restore directories. sudo rm -rf www/web/profiles www/web/sites mv ./profiles www/web/profiles mv ./sites www/web/sites # Update farmOS profile. cd www/web/profiles/farm git checkout 2.x && git pull origin 2.x # Run Drupal database updates. docker-compose exec -u www-data www drush updb","title":"Updating local environment"},{"location":"development/module/","text":"farmOS module development \u00b6 farmOS modules can be written to extend the capabilities of farmOS. This document describes how to get started with farmOS module development. For detailed documentation of Drupal development more generally, refer to the guide on drupal.org . Modules directory \u00b6 Modules should be placed in the modules directory of the server's document root, at the same level as the profiles directory, which contains the farm profile (farmOS). If you are using the farmOS Docker image, this will be: /var/opt/drupal/web/modules farmOS automatically puts Drupal module dependencies in modules/contrib . A good practice is to download farmOS-specific modules into modules/farm to keep them separate. You may also consider creating a modules/custom directory for custom modules that are specific to your farmOS instance. Namespacing \u00b6 A farmOS (Drupal) module must have a unique name consisting only of lowercase alphanumeric characters and underscores. This is used as a namespace throughout the module, and allows Drupal hook functions to be executed on behalf of your module. It is best practice to prefix all farmOS-specific module names with farm_ . For example, if you were to build a module that adds a new log type called irrigation , you might name it farm_irrigation . This serves to specify that this module is made to work with farmOS, and is not designed to be installed in other Drupal sites more generally. File structure \u00b6 A farmOS (Drupal) module only requires one file for it to be recognized as a module: [modulename].info.yml (where [modulename] is the module name). This info YML file contains the module's human readable name, description, dependency declarations, and other meta information about the module. A very simple example looks like this: mylogtype.info.yml : name: My log type description: Adds my new custom log type. type: module package: farmOS Contrib core_version_requirement: ^9 dependencies: - farm:farm_entity Other common files and directories in a module include: [modulename].module - Optional PHP file for Drupal hook implementations. config/install/*.yml - Configuration entities that will be installed with the module. config/optional/*.yml - Optional configuration entities that will only be installed if certain dependencies are met. src/* - PHP classes organized using the PSR-4 autoloading specification. tests/* - Automated tests for the module. Publishing \u00b6 If you want to share your module, consider publishing the repository so that it can be downloaded and installed by other farmOS users. farmOS.org maintains a list of community modules, and accepts new additions via pull requests . It is recommended that \"contributed\" farmOS modules be made available as a \"project\" on Drupal.org . This has two benefits: Projects can be included via Composer with: composer require drupal/mymodule Translations can be automatically managed and downloaded from Drupal's centralized localization server: localize.drupal.org License \u00b6 farmOS modules that are distributed to others must be licensed under the GNU General Public License, version 2 or later . For more information about farmOS and Drupal module licensing requirements, refer to Drupal.org Licensing .","title":"Getting started"},{"location":"development/module/#farmos-module-development","text":"farmOS modules can be written to extend the capabilities of farmOS. This document describes how to get started with farmOS module development. For detailed documentation of Drupal development more generally, refer to the guide on drupal.org .","title":"farmOS module development"},{"location":"development/module/#modules-directory","text":"Modules should be placed in the modules directory of the server's document root, at the same level as the profiles directory, which contains the farm profile (farmOS). If you are using the farmOS Docker image, this will be: /var/opt/drupal/web/modules farmOS automatically puts Drupal module dependencies in modules/contrib . A good practice is to download farmOS-specific modules into modules/farm to keep them separate. You may also consider creating a modules/custom directory for custom modules that are specific to your farmOS instance.","title":"Modules directory"},{"location":"development/module/#namespacing","text":"A farmOS (Drupal) module must have a unique name consisting only of lowercase alphanumeric characters and underscores. This is used as a namespace throughout the module, and allows Drupal hook functions to be executed on behalf of your module. It is best practice to prefix all farmOS-specific module names with farm_ . For example, if you were to build a module that adds a new log type called irrigation , you might name it farm_irrigation . This serves to specify that this module is made to work with farmOS, and is not designed to be installed in other Drupal sites more generally.","title":"Namespacing"},{"location":"development/module/#file-structure","text":"A farmOS (Drupal) module only requires one file for it to be recognized as a module: [modulename].info.yml (where [modulename] is the module name). This info YML file contains the module's human readable name, description, dependency declarations, and other meta information about the module. A very simple example looks like this: mylogtype.info.yml : name: My log type description: Adds my new custom log type. type: module package: farmOS Contrib core_version_requirement: ^9 dependencies: - farm:farm_entity Other common files and directories in a module include: [modulename].module - Optional PHP file for Drupal hook implementations. config/install/*.yml - Configuration entities that will be installed with the module. config/optional/*.yml - Optional configuration entities that will only be installed if certain dependencies are met. src/* - PHP classes organized using the PSR-4 autoloading specification. tests/* - Automated tests for the module.","title":"File structure"},{"location":"development/module/#publishing","text":"If you want to share your module, consider publishing the repository so that it can be downloaded and installed by other farmOS users. farmOS.org maintains a list of community modules, and accepts new additions via pull requests . It is recommended that \"contributed\" farmOS modules be made available as a \"project\" on Drupal.org . This has two benefits: Projects can be included via Composer with: composer require drupal/mymodule Translations can be automatically managed and downloaded from Drupal's centralized localization server: localize.drupal.org","title":"Publishing"},{"location":"development/module/#license","text":"farmOS modules that are distributed to others must be licensed under the GNU General Public License, version 2 or later . For more information about farmOS and Drupal module licensing requirements, refer to Drupal.org Licensing .","title":"License"},{"location":"development/module/entities/","text":"Entity types \u00b6 Assets, logs, plans, taxonomy terms, users, etc are all types of \"entities\" in farmOS/Drupal terminology. Entities can have sub-types called \"bundles\", which represent \"bundles of fields\". Some fields may be common across all bundles of a given entity type, and some fields may be bundle-specific. Adding asset, log, and plan types \u00b6 Asset types, log types, and plan types can be provided by adding two files to a module: An entity type config file (YAML), and: A bundle plugin class (PHP). For example, the \"Activity\" log type is provided as follows: config/install/log.type.activity.yml : langcode: en status: true dependencies: enforced: module: - farm_activity id: activity label: Activity description: '' name_pattern: 'Activity log [log:id]' workflow: log_default new_revision: true src/Plugin/Log/LogType/Activity.php : <?php namespace Drupal\\farm_activity\\Plugin\\Log\\LogType; use Drupal\\farm_entity\\Plugin\\Log\\LogType\\FarmLogType; /** * Provides the activity log type. * * @LogType( * id = \"activity\", * label = @Translation(\"Activity\"), * ) */ class Activity extends FarmLogType { } Bundle fields \u00b6 Bundles can declare field definitions in their plugin class via the buildFieldDefinitions() method. A farm_field.factory helper service is provided to make this easier. The Equipment asset type does this to add \"Manufacturer\", \"Model\", and \"Serial number\" fields: /** * {@inheritdoc} */ public function buildFieldDefinitions() { $fields = parent::buildFieldDefinitions(); $field_info = [ 'manufacturer' => [ 'type' => 'string', 'label' => $this->t('Manufacturer'), 'weight' => [ 'form' => -20, 'view' => -50, ], ], 'model' => [ 'type' => 'string', 'label' => $this->t('Model'), 'weight' => [ 'form' => -15, 'view' => -40, ], ], 'serial_number' => [ 'type' => 'string', 'label' => $this->t('Serial number'), 'weight' => [ 'form' => -10, 'view' => -30, ], ], ]; foreach ($field_info as $name => $info) { $fields[$name] = \\Drupal::service('farm_field.factory')->bundleFieldDefinition($info); } return $fields; } For more information, see Adding fields .","title":"Entities"},{"location":"development/module/entities/#entity-types","text":"Assets, logs, plans, taxonomy terms, users, etc are all types of \"entities\" in farmOS/Drupal terminology. Entities can have sub-types called \"bundles\", which represent \"bundles of fields\". Some fields may be common across all bundles of a given entity type, and some fields may be bundle-specific.","title":"Entity types"},{"location":"development/module/entities/#adding-asset-log-and-plan-types","text":"Asset types, log types, and plan types can be provided by adding two files to a module: An entity type config file (YAML), and: A bundle plugin class (PHP). For example, the \"Activity\" log type is provided as follows: config/install/log.type.activity.yml : langcode: en status: true dependencies: enforced: module: - farm_activity id: activity label: Activity description: '' name_pattern: 'Activity log [log:id]' workflow: log_default new_revision: true src/Plugin/Log/LogType/Activity.php : <?php namespace Drupal\\farm_activity\\Plugin\\Log\\LogType; use Drupal\\farm_entity\\Plugin\\Log\\LogType\\FarmLogType; /** * Provides the activity log type. * * @LogType( * id = \"activity\", * label = @Translation(\"Activity\"), * ) */ class Activity extends FarmLogType { }","title":"Adding asset, log, and plan types"},{"location":"development/module/entities/#bundle-fields","text":"Bundles can declare field definitions in their plugin class via the buildFieldDefinitions() method. A farm_field.factory helper service is provided to make this easier. The Equipment asset type does this to add \"Manufacturer\", \"Model\", and \"Serial number\" fields: /** * {@inheritdoc} */ public function buildFieldDefinitions() { $fields = parent::buildFieldDefinitions(); $field_info = [ 'manufacturer' => [ 'type' => 'string', 'label' => $this->t('Manufacturer'), 'weight' => [ 'form' => -20, 'view' => -50, ], ], 'model' => [ 'type' => 'string', 'label' => $this->t('Model'), 'weight' => [ 'form' => -15, 'view' => -40, ], ], 'serial_number' => [ 'type' => 'string', 'label' => $this->t('Serial number'), 'weight' => [ 'form' => -10, 'view' => -30, ], ], ]; foreach ($field_info as $name => $info) { $fields[$name] = \\Drupal::service('farm_field.factory')->bundleFieldDefinition($info); } return $fields; } For more information, see Adding fields .","title":"Bundle fields"},{"location":"development/module/fields/","text":"Fields \u00b6 Adding fields \u00b6 A module may add additional fields to assets, logs, and other entity types in farmOS. The following documents how to add fields to existing entity types. See Entity types to understand how to create new asset, log, and plan types with custom fields on them. Base fields \u00b6 If the field should be added to all bundles of a given entity type (eg: all log types), then they should be added as \"base fields\" via hook_entity_base_field_info() . A farm_field.factory helper service is provided to make this easier: <?php use Drupal\\Core\\Entity\\EntityTypeInterface; /** * Implements hook_entity_base_field_info(). */ function mymodule_entity_base_field_info(EntityTypeInterface $entity_type) { $fields = []; // Add a new string field to Log entities. if ($entity_type->id() == 'log') { $options = [ 'type' => 'string', 'label' => t('My new field'), 'description' => t('My field description.'), 'weight' => [ 'form' => 10, 'view' => 10, ], ]; $fields['myfield'] = \\Drupal::service('farm_field.factory')->baseFieldDefinition($options); } return $fields; } Bundle fields \u00b6 If the field should only be added to a single bundle (eg: only \"Input\" logs), then they should be added as \"bundle fields\" via hook_farm_entity_bundle_field_info() * * Note that this is a custom hook provided by farmOS, which may be deprecated in favor of a core Drupal hook in the future. See core issue: https://www.drupal.org/node/2346347 The format for bundle field definitions is identical to base field definitions (above), but the bundleFieldDefinition() method must be used instead of baseFieldDefinition() . <?php use Drupal\\Core\\Entity\\EntityTypeInterface; /** * Implements hook_farm_entity_bundle_field_info(). */ function mymodule_farm_entity_bundle_field_info(EntityTypeInterface $entity_type, $bundle) { $fields = []; // Add a new string field to Input Logs. if ($entity_type->id() == 'log' && $bundle == 'input') { $options = [ 'type' => 'string', 'label' => t('My new field'), 'description' => t('My field description.'), 'weight' => [ 'form' => 10, 'view' => 10, ], ]; $fields['myfield'] = \\Drupal::service('farm_field.factory')->bundleFieldDefinition($options); } return $fields; } Select options \u00b6 Certain fields on assets and logs include a list of options to select from. These include: Flags (on assets and logs) Monitor ( monitor ) Needs review ( needs_review ) Priority ( priority ) Lab test type (on Lab test logs) Soil test ( soil ) Water test ( water ) ID tag type (on assets) Electronic ID ( eid , on all assets) Other ( other , on all assets) Brand ( brand , on Animal assets) Ear tag ( ear_tag , on Animal assets) Leg band ( leg_band , on Animal assets) Tattoo ( tattoo , on Animal assets) These options are provided as configuration entities by farmOS modules in the form of YAML files. Existing options can be overridden or removed by editing/deleting the entities in the active configuration of the site. ( Warning changing core types runs the risk of conflicting with future farmOS updates). Examples: \u00b6 Flag \u00b6 An \"Organic\" flag can be provided by a module named my_module by creating a file called farm_flag.flag.organic.yml in my_module/config/install : langcode: en status: true dependencies: enforced: module: - my_module id: monitor label: Monitor The most important parts are the id , which is a unique machine name for the flag, and label , which is the human readable/translatable label that will be shown in the select field and other parts of the UI. The langcode and status and dependencies are standard configuration entity properties. By putting the module's name in \"enforced modules\" it will ensure that the flag is removed when the module is uninstalled. Lab test type \u00b6 The \"Lab test\" module in farmOS provides a \"Soil test\" type like this: lab_test/config/install/farm_lab_test.lab_test_type.soil.yml langcode: en status: true dependencies: enforced: module: - farm_lab_test id: soil label: Soil test ID tag type \u00b6 ID tag types are similar to Flags, in that they have an id and label , but they also have an additional property: bundle . This allows the tag type to be limited to certain types of assets. For example, an \"Ear tag\" type, provided by the \"Animal asset\" module, only applies to \"Animal\" assets: animal/config/install/farm_flag.flag.ear_tag.yml langcode: en status: true dependencies: enforced: module: - farm_animal - farm_id_tag id: ear_tag label: Ear tag bundles: - animal If you want the tag type to apply to all assets, set bundles: null . (or can it just be omitted?)","title":"Fields"},{"location":"development/module/fields/#fields","text":"","title":"Fields"},{"location":"development/module/fields/#adding-fields","text":"A module may add additional fields to assets, logs, and other entity types in farmOS. The following documents how to add fields to existing entity types. See Entity types to understand how to create new asset, log, and plan types with custom fields on them.","title":"Adding fields"},{"location":"development/module/fields/#base-fields","text":"If the field should be added to all bundles of a given entity type (eg: all log types), then they should be added as \"base fields\" via hook_entity_base_field_info() . A farm_field.factory helper service is provided to make this easier: <?php use Drupal\\Core\\Entity\\EntityTypeInterface; /** * Implements hook_entity_base_field_info(). */ function mymodule_entity_base_field_info(EntityTypeInterface $entity_type) { $fields = []; // Add a new string field to Log entities. if ($entity_type->id() == 'log') { $options = [ 'type' => 'string', 'label' => t('My new field'), 'description' => t('My field description.'), 'weight' => [ 'form' => 10, 'view' => 10, ], ]; $fields['myfield'] = \\Drupal::service('farm_field.factory')->baseFieldDefinition($options); } return $fields; }","title":"Base fields"},{"location":"development/module/fields/#bundle-fields","text":"If the field should only be added to a single bundle (eg: only \"Input\" logs), then they should be added as \"bundle fields\" via hook_farm_entity_bundle_field_info() * * Note that this is a custom hook provided by farmOS, which may be deprecated in favor of a core Drupal hook in the future. See core issue: https://www.drupal.org/node/2346347 The format for bundle field definitions is identical to base field definitions (above), but the bundleFieldDefinition() method must be used instead of baseFieldDefinition() . <?php use Drupal\\Core\\Entity\\EntityTypeInterface; /** * Implements hook_farm_entity_bundle_field_info(). */ function mymodule_farm_entity_bundle_field_info(EntityTypeInterface $entity_type, $bundle) { $fields = []; // Add a new string field to Input Logs. if ($entity_type->id() == 'log' && $bundle == 'input') { $options = [ 'type' => 'string', 'label' => t('My new field'), 'description' => t('My field description.'), 'weight' => [ 'form' => 10, 'view' => 10, ], ]; $fields['myfield'] = \\Drupal::service('farm_field.factory')->bundleFieldDefinition($options); } return $fields; }","title":"Bundle fields"},{"location":"development/module/fields/#select-options","text":"Certain fields on assets and logs include a list of options to select from. These include: Flags (on assets and logs) Monitor ( monitor ) Needs review ( needs_review ) Priority ( priority ) Lab test type (on Lab test logs) Soil test ( soil ) Water test ( water ) ID tag type (on assets) Electronic ID ( eid , on all assets) Other ( other , on all assets) Brand ( brand , on Animal assets) Ear tag ( ear_tag , on Animal assets) Leg band ( leg_band , on Animal assets) Tattoo ( tattoo , on Animal assets) These options are provided as configuration entities by farmOS modules in the form of YAML files. Existing options can be overridden or removed by editing/deleting the entities in the active configuration of the site. ( Warning changing core types runs the risk of conflicting with future farmOS updates).","title":"Select options"},{"location":"development/module/fields/#examples","text":"","title":"Examples:"},{"location":"development/module/fields/#flag","text":"An \"Organic\" flag can be provided by a module named my_module by creating a file called farm_flag.flag.organic.yml in my_module/config/install : langcode: en status: true dependencies: enforced: module: - my_module id: monitor label: Monitor The most important parts are the id , which is a unique machine name for the flag, and label , which is the human readable/translatable label that will be shown in the select field and other parts of the UI. The langcode and status and dependencies are standard configuration entity properties. By putting the module's name in \"enforced modules\" it will ensure that the flag is removed when the module is uninstalled.","title":"Flag"},{"location":"development/module/fields/#lab-test-type","text":"The \"Lab test\" module in farmOS provides a \"Soil test\" type like this: lab_test/config/install/farm_lab_test.lab_test_type.soil.yml langcode: en status: true dependencies: enforced: module: - farm_lab_test id: soil label: Soil test","title":"Lab test type"},{"location":"development/module/fields/#id-tag-type","text":"ID tag types are similar to Flags, in that they have an id and label , but they also have an additional property: bundle . This allows the tag type to be limited to certain types of assets. For example, an \"Ear tag\" type, provided by the \"Animal asset\" module, only applies to \"Animal\" assets: animal/config/install/farm_flag.flag.ear_tag.yml langcode: en status: true dependencies: enforced: module: - farm_animal - farm_id_tag id: ear_tag label: Ear tag bundles: - animal If you want the tag type to apply to all assets, set bundles: null . (or can it just be omitted?)","title":"ID tag type"},{"location":"development/module/oauth/","text":"OAuth \u00b6 The Simple OAuth module is used to provide an OAuth2 standard authorization server. For documentation on using and authenticating with the farmOS API see API . Providing OAuth Clients \u00b6 OAuth clients are modeled as \"Consumer\" entities (provided by the Consumers module. The farm_api module provides a default client with client_id = farm . This can be used for general usage of the API, but comes with limitations. To create a third party integration with farmOS a consumer entity must be created that identifies the integration and configures the OAuth Client authorization behavior. Scopes \u00b6 OAuth scopes define different levels of permission. OAuth clients are configured with the scopes needed for the purposes of a specific integration. With consumers, these scopes are implemented as Drupal Roles. This means that OAuth clients interacting with farmOS over the API use the same permission system as Users normally using the site. Client Configuration \u00b6 Standard Consumer configuration: consumer.label - A label used to identify the third party integration. consumer.client_id - An optional client_id machine name to identify the consumer. The simple_oauth module uses a UUID by default, but a machine name makes it easier to identify clients across multiple farmOS servers. consumer.secret - A client_secret used to secure the OAuth client. consumer.confidential - A boolean indicating whether the client secret needs to be validated. Most farmOS third party integrations will disable this. Otherwise the same client_secret must be configured on all farmOS servers, or the third party must keep track of a different secret for each server. This challenge is due to the nature of farmOS being a self-hosted application. consumer.user_id - When no specific user is authenticated Drupal will use this user as the author of all the actions made by this consumer. This is only the case during the Client Credentials authorization flow. consumer.redirect_uri - The URI this client will redirect to when needed. This is used with the Authorization Code authorization flow. consumer.third_party - Enable if the Consumer represents a third party. Users will skip the \"grant\" step of the authorization flow for first party consumers only. farmOS extends the consumers and simple_oauth modules to provide additional authorization options on consumer entities. These additional options make it possible to support different third party integration use cases via the same OAuth Authorization server. They can be configured via the UI or when creating a consumer entity programmatically. Authorization options (all are disabled by default): consumer.grant_user_access - Always grant the authorizing user's access to this consumer. This is how the farmOS Field Kit consumer is configured. If this is the only option enabled, then the consumer will only be granted the roles the user has access to. consumer.limit_requested_access - Only grant this consumer the scopes requested during authorization. By default, all scopes configured with the consumer will be granted during authorization. This allows users to select which scopes they want to grant the third party during authorization. consumer.limit_user_access - Never grant the consumer more access than the authorizing user. It is possible that clients will be configured with different roles than the user that authorizes access to a third party. There are times that this may be intentional, but this setting ensures that consumers will not be granted more access than the authorizing user.","title":"OAuth"},{"location":"development/module/oauth/#oauth","text":"The Simple OAuth module is used to provide an OAuth2 standard authorization server. For documentation on using and authenticating with the farmOS API see API .","title":"OAuth"},{"location":"development/module/oauth/#providing-oauth-clients","text":"OAuth clients are modeled as \"Consumer\" entities (provided by the Consumers module. The farm_api module provides a default client with client_id = farm . This can be used for general usage of the API, but comes with limitations. To create a third party integration with farmOS a consumer entity must be created that identifies the integration and configures the OAuth Client authorization behavior.","title":"Providing OAuth Clients"},{"location":"development/module/oauth/#scopes","text":"OAuth scopes define different levels of permission. OAuth clients are configured with the scopes needed for the purposes of a specific integration. With consumers, these scopes are implemented as Drupal Roles. This means that OAuth clients interacting with farmOS over the API use the same permission system as Users normally using the site.","title":"Scopes"},{"location":"development/module/oauth/#client-configuration","text":"Standard Consumer configuration: consumer.label - A label used to identify the third party integration. consumer.client_id - An optional client_id machine name to identify the consumer. The simple_oauth module uses a UUID by default, but a machine name makes it easier to identify clients across multiple farmOS servers. consumer.secret - A client_secret used to secure the OAuth client. consumer.confidential - A boolean indicating whether the client secret needs to be validated. Most farmOS third party integrations will disable this. Otherwise the same client_secret must be configured on all farmOS servers, or the third party must keep track of a different secret for each server. This challenge is due to the nature of farmOS being a self-hosted application. consumer.user_id - When no specific user is authenticated Drupal will use this user as the author of all the actions made by this consumer. This is only the case during the Client Credentials authorization flow. consumer.redirect_uri - The URI this client will redirect to when needed. This is used with the Authorization Code authorization flow. consumer.third_party - Enable if the Consumer represents a third party. Users will skip the \"grant\" step of the authorization flow for first party consumers only. farmOS extends the consumers and simple_oauth modules to provide additional authorization options on consumer entities. These additional options make it possible to support different third party integration use cases via the same OAuth Authorization server. They can be configured via the UI or when creating a consumer entity programmatically. Authorization options (all are disabled by default): consumer.grant_user_access - Always grant the authorizing user's access to this consumer. This is how the farmOS Field Kit consumer is configured. If this is the only option enabled, then the consumer will only be granted the roles the user has access to. consumer.limit_requested_access - Only grant this consumer the scopes requested during authorization. By default, all scopes configured with the consumer will be granted during authorization. This allows users to select which scopes they want to grant the third party during authorization. consumer.limit_user_access - Never grant the consumer more access than the authorizing user. It is possible that clients will be configured with different roles than the user that authorizes access to a third party. There are times that this may be intentional, but this setting ensures that consumers will not be granted more access than the authorizing user.","title":"Client Configuration"},{"location":"development/module/roles/","text":"Roles \u00b6 Roles are groups of permissions that can be assigned to users to grant them granular access to data and features in farmOS. Module developers can define new roles, and specify which permissions they should include. farmOS also builds on top of Drupal's role and permission system to provide a concept of \"Managed Roles\". Managed Roles \u00b6 The farmOS Access module provides methods to create user roles with permissions that are managed for the purposes of farmOS. These roles cannot be modified from the Admin Permissions UI. Instead, these roles allow permissions to be provided by other modules that want to provide sensible defaults for common farmOS roles. Creating a managed role \u00b6 User roles are provided as Drupal Configuration Entities. Managed roles are provided in the same way the only difference being that they include additional third party settings the farmOS Access module uses to build managed permissions. The user.role.*.third_party.farm_acccess schema defines the structure of these settings. access : An optional array of default access permissions. config : Boolean that specifies whether the role should have access to configuration. Only grant this to trusted roles. entity : Access permissions relating to entities. view all : Boolean that specifies the role should have access to view all bundles of all entity types. create all : Boolean that specifies the role should have access to create all bundles of all entity types. update all : Boolean that specifies the role should have access to update all bundles of all entity types. delete all : Boolean that specifies the role should have access to delete all bundles of all entity types. type : Access permissions for specific entity types. {entity_type} : The id of the entity type. eg: log , asset , taxonomy_term , etc. {operation} : The operation to grant bundles of this entity type. Eg: create , view any , view own , delete any , delete own , etc. {bundle} : The id of the entity type bundle or all to grant the operation permission to all bundles of the entity type. Settings used for the Manager role (full access to all entities + access to configuration): user.role.farm_manager.yml # (standard role config goes here) third_party_settings: farm_role: access: config: true entity: view all: true create all: true update all: true delete all: true Example settings to define a \"Harvester\" role with these limitations: View all log entities. Only create harvest logs, update harvest logs, and delete own harvest logs. View all asset entities. Only update planting assets. View, edit and delete any taxonomy_term entity. user.role.farm_harvester.yml # (standard role config goes here) third_party_settings: farm_role: access: entity: view all: true type: log: create: - harvest update any: - harvest delete own: - harvest asset: update any: - planting taxonomy_term: edit: - all delete: - all Providing permissions for managed roles \u00b6 Modules can define sensible permissions to any managed roles. These permissions are provided by creating a ManagedRolePermissions plugin in the module.managed_role_permissions.yml file. The following keys can be provided: default_permissions : A list of permissions that will be added to all managed roles. config_permissions : A list of permissions that will be added to managed roles that have access to configuration ( config: true ). permission_callbacks : A list of callbacks in controller notation that return an array of permissions to add to managed roles. Callbacks are provided a Role object so that permissions can be applied conditionally based on the managed role's settings. As an example, the farm_role module provides the following permissions: farm_role.managed_role_permissions.yml farm_role: default_permissions: - access content - access administration pages - access user profiles - access taxonomy overview config_permissions: - administer taxonomy Permission callbacks \u00b6 Example that adds permissions conditionally based on the role name and settings: Plugin definition: my_module.managed_role_permissions.yml my_module: permission_callbacks: - Drupal\\my_module\\CustomPermissions::permissions Example implementation of a permission_callback : my_module/src/CustomPermissions.php <?php namespace Drupal\\my_module; use Drupal\\user\\RoleInterface; /** * Example custom permission callback. */ class CustomPermissions { /** * Return an array of permission strings that will be added to the role. * * @param \\Drupal\\user\\RoleInterface $role * The role to add permissions to. * * @return array * An array of permission strings. */ public function permissions(RoleInterface $role) { // Array of permissions to return. $perms = []; // Add permissions based on role name. if ($role->id() == 'farm_manager') { $perms = 'my manager permission'; } // Get the farm_role third party settings from the Role entity. $access_settings = $role->getThirdPartySetting('farm_role', 'access'); $entity_settings = $access_settings['entity'] ?: []; // Only add permissions if `update all` and `delete all` are true. if (!empty($entity_settings['update all'] && $entity_settings['delete all'])) { $perms[] = 'recover all permission'; } // Return array of permissions. return $perms; } }","title":"Roles"},{"location":"development/module/roles/#roles","text":"Roles are groups of permissions that can be assigned to users to grant them granular access to data and features in farmOS. Module developers can define new roles, and specify which permissions they should include. farmOS also builds on top of Drupal's role and permission system to provide a concept of \"Managed Roles\".","title":"Roles"},{"location":"development/module/roles/#managed-roles","text":"The farmOS Access module provides methods to create user roles with permissions that are managed for the purposes of farmOS. These roles cannot be modified from the Admin Permissions UI. Instead, these roles allow permissions to be provided by other modules that want to provide sensible defaults for common farmOS roles.","title":"Managed Roles"},{"location":"development/module/roles/#creating-a-managed-role","text":"User roles are provided as Drupal Configuration Entities. Managed roles are provided in the same way the only difference being that they include additional third party settings the farmOS Access module uses to build managed permissions. The user.role.*.third_party.farm_acccess schema defines the structure of these settings. access : An optional array of default access permissions. config : Boolean that specifies whether the role should have access to configuration. Only grant this to trusted roles. entity : Access permissions relating to entities. view all : Boolean that specifies the role should have access to view all bundles of all entity types. create all : Boolean that specifies the role should have access to create all bundles of all entity types. update all : Boolean that specifies the role should have access to update all bundles of all entity types. delete all : Boolean that specifies the role should have access to delete all bundles of all entity types. type : Access permissions for specific entity types. {entity_type} : The id of the entity type. eg: log , asset , taxonomy_term , etc. {operation} : The operation to grant bundles of this entity type. Eg: create , view any , view own , delete any , delete own , etc. {bundle} : The id of the entity type bundle or all to grant the operation permission to all bundles of the entity type. Settings used for the Manager role (full access to all entities + access to configuration): user.role.farm_manager.yml # (standard role config goes here) third_party_settings: farm_role: access: config: true entity: view all: true create all: true update all: true delete all: true Example settings to define a \"Harvester\" role with these limitations: View all log entities. Only create harvest logs, update harvest logs, and delete own harvest logs. View all asset entities. Only update planting assets. View, edit and delete any taxonomy_term entity. user.role.farm_harvester.yml # (standard role config goes here) third_party_settings: farm_role: access: entity: view all: true type: log: create: - harvest update any: - harvest delete own: - harvest asset: update any: - planting taxonomy_term: edit: - all delete: - all","title":"Creating a managed role"},{"location":"development/module/roles/#providing-permissions-for-managed-roles","text":"Modules can define sensible permissions to any managed roles. These permissions are provided by creating a ManagedRolePermissions plugin in the module.managed_role_permissions.yml file. The following keys can be provided: default_permissions : A list of permissions that will be added to all managed roles. config_permissions : A list of permissions that will be added to managed roles that have access to configuration ( config: true ). permission_callbacks : A list of callbacks in controller notation that return an array of permissions to add to managed roles. Callbacks are provided a Role object so that permissions can be applied conditionally based on the managed role's settings. As an example, the farm_role module provides the following permissions: farm_role.managed_role_permissions.yml farm_role: default_permissions: - access content - access administration pages - access user profiles - access taxonomy overview config_permissions: - administer taxonomy","title":"Providing permissions for managed roles"},{"location":"development/module/roles/#permission-callbacks","text":"Example that adds permissions conditionally based on the role name and settings: Plugin definition: my_module.managed_role_permissions.yml my_module: permission_callbacks: - Drupal\\my_module\\CustomPermissions::permissions Example implementation of a permission_callback : my_module/src/CustomPermissions.php <?php namespace Drupal\\my_module; use Drupal\\user\\RoleInterface; /** * Example custom permission callback. */ class CustomPermissions { /** * Return an array of permission strings that will be added to the role. * * @param \\Drupal\\user\\RoleInterface $role * The role to add permissions to. * * @return array * An array of permission strings. */ public function permissions(RoleInterface $role) { // Array of permissions to return. $perms = []; // Add permissions based on role name. if ($role->id() == 'farm_manager') { $perms = 'my manager permission'; } // Get the farm_role third party settings from the Role entity. $access_settings = $role->getThirdPartySetting('farm_role', 'access'); $entity_settings = $access_settings['entity'] ?: []; // Only add permissions if `update all` and `delete all` are true. if (!empty($entity_settings['update all'] && $entity_settings['delete all'])) { $perms[] = 'recover all permission'; } // Return array of permissions. return $perms; } }","title":"Permission callbacks"},{"location":"development/module/updates/","text":"Automated updates \u00b6 farmOS modules may change and evolve over time. If these changes require updates to a farmOS database or configuration, then update logic should be provided so that users of the module can perform the necessary changes automatically when they update to the new version. This logic can be supplied via implementations of hook_update_N() . For more information, see the documentation for Drupal's Update API .","title":"Updates"},{"location":"development/module/updates/#automated-updates","text":"farmOS modules may change and evolve over time. If these changes require updates to a farmOS database or configuration, then update logic should be provided so that users of the module can perform the necessary changes automatically when they update to the new version. This logic can be supplied via implementations of hook_update_N() . For more information, see the documentation for Drupal's Update API .","title":"Automated updates"},{"location":"hosting/migration/","text":"Migrating from farmOS 1.x to 2.x \u00b6 Install farmOS 2.x. Install the farmOS modules you intend to use (this will determine what data is migrated). Add farmOS 1.x database connection info to settings.php : $databases['migrate']['default'] = [ 'database' => 'my_farmos_1x_db', 'username' => 'my-db-username', 'password' => 'my-db-password', 'prefix' => '', 'host' => 'localhost', 'port' => '3306', 'namespace' => 'Drupal\\\\Core\\\\Database\\\\Driver\\\\mysql', 'driver' => 'mysql', ]; Copy user-uploaded files to the new directory (see \"Uploaded files\" below). Install the farmOS Migrate ( farm_migrate ) module. Run the farmOS 1.x Migrations via Drush (in this order): drush migrate:import --group=farm_migrate drush migrate:import --group=farm_migrate_taxonomy drush migrate:import --group=farm_migrate_asset drush migrate:import --group=farm_migrate_log drush migrate:import --group=farm_migrate_reference To view the status of all farmOS 1.x migrations: drush migrate:status --tag=\"farmOS 1.x\" Uploaded files \u00b6 farmOS allows files to be uploaded/attached to records. In order to migrate these files, they need to be copied into new site's files/private directories. The farmOS migration code will look for files in the following locations: Public files: public://migrate Private files: private://migrate The public:// and private:// prefixes map to the \"Public file system path\" and \"Private file system path\" configured in farmOS 1.x and 2.x at: /admin/config/media/file-system . This may vary for each installation. For example, if you have farmOS 1.x installed in /var/www/farmOS_1.x and farmOS 2.x in /var/www/farmOS_2.x , and both are configured to use sites/default/files for public files, and sites/default/private for private files, then copy the files as follows: cp -rp /var/www/farmOS_1.x/sites/default/files /var/www/farmOS_2.x/sites/default/files/migrate cp -rp /var/www/farmOS_1.x/sites/default/private/files /var/www/farmOS_2.x/sites/default/private/files/migrate The farmOS migration code will automatically move files from files/migrate/* to files/* . Only the files that it finds in the {file_managed} table will be moved, leaving behind various temporary files in the migrate directory that are no longer needed after the migration. This migrate directory can be deleted after the migration, once it has been confirmed that everything was migrated successfully. Limitations \u00b6 The farmOS migration code is designed to migrate a default farmOS 1.x database to 2.x. If any customizations have been made on top of the defaults, they will not be migrated. This includes (but is not limited to): Custom asset, entity, taxonomies, and log types Custom fields Custom roles If you maintain a contrib/custom module for farmOS 1.x, it is your responsibility to update the modules for 2.x and provide migration logic.","title":"1.x Migration"},{"location":"hosting/migration/#migrating-from-farmos-1x-to-2x","text":"Install farmOS 2.x. Install the farmOS modules you intend to use (this will determine what data is migrated). Add farmOS 1.x database connection info to settings.php : $databases['migrate']['default'] = [ 'database' => 'my_farmos_1x_db', 'username' => 'my-db-username', 'password' => 'my-db-password', 'prefix' => '', 'host' => 'localhost', 'port' => '3306', 'namespace' => 'Drupal\\\\Core\\\\Database\\\\Driver\\\\mysql', 'driver' => 'mysql', ]; Copy user-uploaded files to the new directory (see \"Uploaded files\" below). Install the farmOS Migrate ( farm_migrate ) module. Run the farmOS 1.x Migrations via Drush (in this order): drush migrate:import --group=farm_migrate drush migrate:import --group=farm_migrate_taxonomy drush migrate:import --group=farm_migrate_asset drush migrate:import --group=farm_migrate_log drush migrate:import --group=farm_migrate_reference To view the status of all farmOS 1.x migrations: drush migrate:status --tag=\"farmOS 1.x\"","title":"Migrating from farmOS 1.x to 2.x"},{"location":"hosting/migration/#uploaded-files","text":"farmOS allows files to be uploaded/attached to records. In order to migrate these files, they need to be copied into new site's files/private directories. The farmOS migration code will look for files in the following locations: Public files: public://migrate Private files: private://migrate The public:// and private:// prefixes map to the \"Public file system path\" and \"Private file system path\" configured in farmOS 1.x and 2.x at: /admin/config/media/file-system . This may vary for each installation. For example, if you have farmOS 1.x installed in /var/www/farmOS_1.x and farmOS 2.x in /var/www/farmOS_2.x , and both are configured to use sites/default/files for public files, and sites/default/private for private files, then copy the files as follows: cp -rp /var/www/farmOS_1.x/sites/default/files /var/www/farmOS_2.x/sites/default/files/migrate cp -rp /var/www/farmOS_1.x/sites/default/private/files /var/www/farmOS_2.x/sites/default/private/files/migrate The farmOS migration code will automatically move files from files/migrate/* to files/* . Only the files that it finds in the {file_managed} table will be moved, leaving behind various temporary files in the migrate directory that are no longer needed after the migration. This migrate directory can be deleted after the migration, once it has been confirmed that everything was migrated successfully.","title":"Uploaded files"},{"location":"hosting/migration/#limitations","text":"The farmOS migration code is designed to migrate a default farmOS 1.x database to 2.x. If any customizations have been made on top of the defaults, they will not be migrated. This includes (but is not limited to): Custom asset, entity, taxonomies, and log types Custom fields Custom roles If you maintain a contrib/custom module for farmOS 1.x, it is your responsibility to update the modules for 2.x and provide migration logic.","title":"Limitations"}]}