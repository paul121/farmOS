{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"farmOS 2.x \u00b6 ATTENTION: This documentation is for the 2.x branch of farmOS, which is under active development. If you want to use farmOS, the recommended stable branch is 7.x-1.x. farmOS 1.x documentation is available at http://farmOS.org .","title":"farmOS 2.x"},{"location":"#farmos-2x","text":"ATTENTION: This documentation is for the 2.x branch of farmOS, which is under active development. If you want to use farmOS, the recommended stable branch is 7.x-1.x. farmOS 1.x documentation is available at http://farmOS.org .","title":"farmOS 2.x"},{"location":"development/api/","text":"API \u00b6 farmOS provides an API that other applications/systems can use to read and write records via HTTP requests. The root API endpoint is /api . farmOS adheres to the JSON:API specification, and JSON Schema is used to describe the available API resources. To begin exploring the farmOS API schema, visit /api/schema . From there, you can traverse a graph of interconnected schemas describing the entire API.","title":"Introduction"},{"location":"development/api/#api","text":"farmOS provides an API that other applications/systems can use to read and write records via HTTP requests. The root API endpoint is /api . farmOS adheres to the JSON:API specification, and JSON Schema is used to describe the available API resources. To begin exploring the farmOS API schema, visit /api/schema . From there, you can traverse a graph of interconnected schemas describing the entire API.","title":"API"},{"location":"development/api/authentication/","text":"Authentication \u00b6 farmOS includes an OAuth2 Authorization server for providing 1st and 3rd party clients access to the farmOS API. Rather than using a user's username and password to both authorize and authenticate a request, OAuth2 requires users to complete an authorization flow that generates an access_token to be used for authentication. Access tokens are provided to both 1st and 3rd party clients who wish to access the server's protected resources. Clients store the access token instead of the user's credentials, which makes it a more secure authentication method. Read more about the OAuth 2.0 standards . Client Libraries \u00b6 The farmOS.py and farmOS.js client libraries use the OAuth2 protocol to interact with the farmOS API. OAuth2 Bearer Tokens \u00b6 Once you have an OAuth2 token, you can authenticate requests to the farmOS server by including an Authentication: Bearer {access_token} header. OAuth2 Details \u00b6 The OAuth protocol defines a process where users authorize 1st and 3rd party clients with scoped access to data on the server. The following describes the details necessary for using OAuth2 authorization with a farmOS server. Scopes \u00b6 OAuth Scopes define different levels of permission. The farmOS server implements scopes as roles associated with OAuth clients. This means that users will authorize clients with roles that determine how much access they have to data on the server. Clients \u00b6 An OAuth Client represents a 1st or 3rd party integration with the farmOS server. Clients are uniquely identified by a client_id and are configured to use different scopes . The core farm_api module provides a default client with client_id = farm . If you are writing a script that communicates with your farmOS server via the API, you should use this client to authorize access and generate an access_token for authentication. If you are creating a third party integration with farmOS, see the OAuth page of the farmOS module development docs for steps to create an OAuth Client. Authorization Flows \u00b6 The OAuth 2.0 standards outline 5 Oauth2 Grant Types to be used in an OAuth2 Authorization Flow - They are the Authorization Code, Implicit, Password Credentials, Client Credentials and Refresh Token Grants. The Authorization Code and Refresh Token grants are the only Authorization Flows recommended by farmOS for use with 3rd party clients. NOTE: Only use the Password Grant if the client can be trusted with a farmOS username and password (this is considered 1st party ). The Client Credentials Grant is often used for machine authentication not associated with a user account. The client credentials grant should only be used if a client_secret can be kept secret. If connecting to multiple farmOS servers, each server should use a different secret. This is challenging due to the nature of farmOS being a self-hosted application. Authorization Code Grant \u00b6 The Authorization Code Grant is most popular for 3rd party client authorization. Requesting resources is a four step process: First : the client sends a request to the farmOS server /oauth/authorize endpoint requesting an Authorization Code . The user logs in and authorizes the client to have the OAuth Scopes it is requesting. Copy this link to browser - http://localhost/oauth/authorize?response_type=code&client_id=farmos_development&scope=user_access&redirect_uri=http://localhost/api/authorized&state=p4W8P5f7gJCIDbC1Mv78zHhlpJOidy Second : after the user accepts, the server redirects to the redirect_uri with an authorization code and state in the query parameters. Example redirect url from server: http://localhost/api/authorized?code=9eb9442c7a2b011fd59617635cca5421cd089943&state=p4W8P5f7gJCIDbC1Mv78zHhlpJOidy Third : copy the code and state from the URL into the body of a POST request. The grant_type , client_id , client_secret and redirect_uri must also be included in the POST body. The client makes a POST request to the /oauth/token endpoint to retrieve an access_token and refresh_token . foo@bar:~$ curl -X POST -d \"grant_type=authorization_code&code=ae4d1381cc67def1c10dc88a19af6ac30d7b5959&client_id=farmos_development&redirect_uri=http://localhost/api/authorized\" http://localhost/oauth/token {\"access_token\":\"3f9212c4a6656f1cd1304e47307927a7c224abb0\",\"expires_in\":\"10\",\"token_type\":\"Bearer\",\"scope\":\"user_access\",\"refresh_token\":\"292810b04d688bfb5c3cee28e45637ec8ef1dd9e\"} Fourth : the client sends the access token in the request header to access protected resources. The header is an Authorization header with a Bearer token: Authorization: Bearer access_token foo@bar:~$ curl --header \"Authorization: Bearer b872daf5827a75495c8194c6bfa4f90cf46c143e\" http://localhost/farm.json {\"name\":\"farmos-server\",\"url\":\"http:\\/\\/localhost\",\"api_version\":\"1.1\",\"user\":{\"uid\":\"1\",\"name\":\"admin\", .... Password Credentials Grant \u00b6 NOTE: Only use the Password Grant if the client can be trusted with a farmOS username and password (this is considered 1st party ). The Password Credentials Grant uses a farmOS username and password to retrieve an access_token and refresh_token in one step. For the user, this is the simplest type of authorization. Because the client can be trusted with their farmOS Credentials, a users username and password can be collected directly into a login form within the client application. These credentials are then used (not stored) to request tokens which are used for authentication with the farmOS server and retrieving data. Requesting protected resources is a two step process: First , the client sends a POST request to the farmOS server /oauth/token endpoint with grant_type set to password and a username and password included in the request body. $ curl -X POST -d \"grant_type=password&username=username&password=test&client_id=farm&scope=user_access\" http://localhost/oauth/token {\"access_token\":\"e69c60dea3f5c59c95863928fa6fb860d3506fe9\",\"expires_in\":\"300\",\"token_type\":\"Bearer\",\"scope\":\"user_access\",\"refresh_token\":\"cead7d46d18d74daea83f114bc0b512ec4cc31c3\"} second , the client sends the access_token in the request header to access protected resources. The header is an Authorization header with a Bearer token: Authorization: Bearer access_token foo@bar:~$ curl --header \"Authorization: Bearer e69c60dea3f5c59c95863928fa6fb860d3506fe9\" http://localhost/farm.json {\"name\":\"farmos-server\",\"url\":\"http:\\/\\/localhost\",\"api_version\":\"1.1\",\"user\":{\"uid\":\"1\",\"name\":\"admin\", .... Refreshing Tokens \u00b6 The refresh_token can be used to retrieve a new access_token if the token has expired. It is a one step process: The client sends an authenticated request to the /oauth/token endpoint with grant_type set to refresh_token and includes the refresh_token , client_id and client_secret in the request body. foo@bar:~$ curl -X POST -H 'Authorization: Bearer ad52c04d26c1002084501d28b59196996f0bd93f' -d 'refresh_token=52e7a0e12e8ddd08b155b3b3ee385687fef01664&grant_type=refresh_token&client_id=farmos_api_client&client_secret=client_secret' http://localhost/oauth/token {\"access_token\":\"acdbfabb736e42aa301b50fdda95d6b7fd3e7e14\",\"expires_in\":\"300\",\"token_type\":\"Bearer\",\"scope\":\"user_access\",\"refresh_token\":\"b73f4744840498a26f43447d8cf755238bfd391a\"} The server responds with an access_token and refresh_token that can be used in future requests. The previous access_token and refresh_token will no longer work.","title":"Authentication"},{"location":"development/api/authentication/#authentication","text":"farmOS includes an OAuth2 Authorization server for providing 1st and 3rd party clients access to the farmOS API. Rather than using a user's username and password to both authorize and authenticate a request, OAuth2 requires users to complete an authorization flow that generates an access_token to be used for authentication. Access tokens are provided to both 1st and 3rd party clients who wish to access the server's protected resources. Clients store the access token instead of the user's credentials, which makes it a more secure authentication method. Read more about the OAuth 2.0 standards .","title":"Authentication"},{"location":"development/api/authentication/#client-libraries","text":"The farmOS.py and farmOS.js client libraries use the OAuth2 protocol to interact with the farmOS API.","title":"Client Libraries"},{"location":"development/api/authentication/#oauth2-bearer-tokens","text":"Once you have an OAuth2 token, you can authenticate requests to the farmOS server by including an Authentication: Bearer {access_token} header.","title":"OAuth2 Bearer Tokens"},{"location":"development/api/authentication/#oauth2-details","text":"The OAuth protocol defines a process where users authorize 1st and 3rd party clients with scoped access to data on the server. The following describes the details necessary for using OAuth2 authorization with a farmOS server.","title":"OAuth2 Details"},{"location":"development/api/authentication/#scopes","text":"OAuth Scopes define different levels of permission. The farmOS server implements scopes as roles associated with OAuth clients. This means that users will authorize clients with roles that determine how much access they have to data on the server.","title":"Scopes"},{"location":"development/api/authentication/#clients","text":"An OAuth Client represents a 1st or 3rd party integration with the farmOS server. Clients are uniquely identified by a client_id and are configured to use different scopes . The core farm_api module provides a default client with client_id = farm . If you are writing a script that communicates with your farmOS server via the API, you should use this client to authorize access and generate an access_token for authentication. If you are creating a third party integration with farmOS, see the OAuth page of the farmOS module development docs for steps to create an OAuth Client.","title":"Clients"},{"location":"development/api/authentication/#authorization-flows","text":"The OAuth 2.0 standards outline 5 Oauth2 Grant Types to be used in an OAuth2 Authorization Flow - They are the Authorization Code, Implicit, Password Credentials, Client Credentials and Refresh Token Grants. The Authorization Code and Refresh Token grants are the only Authorization Flows recommended by farmOS for use with 3rd party clients. NOTE: Only use the Password Grant if the client can be trusted with a farmOS username and password (this is considered 1st party ). The Client Credentials Grant is often used for machine authentication not associated with a user account. The client credentials grant should only be used if a client_secret can be kept secret. If connecting to multiple farmOS servers, each server should use a different secret. This is challenging due to the nature of farmOS being a self-hosted application.","title":"Authorization Flows"},{"location":"development/api/authentication/#authorization-code-grant","text":"The Authorization Code Grant is most popular for 3rd party client authorization. Requesting resources is a four step process: First : the client sends a request to the farmOS server /oauth/authorize endpoint requesting an Authorization Code . The user logs in and authorizes the client to have the OAuth Scopes it is requesting. Copy this link to browser - http://localhost/oauth/authorize?response_type=code&client_id=farmos_development&scope=user_access&redirect_uri=http://localhost/api/authorized&state=p4W8P5f7gJCIDbC1Mv78zHhlpJOidy Second : after the user accepts, the server redirects to the redirect_uri with an authorization code and state in the query parameters. Example redirect url from server: http://localhost/api/authorized?code=9eb9442c7a2b011fd59617635cca5421cd089943&state=p4W8P5f7gJCIDbC1Mv78zHhlpJOidy Third : copy the code and state from the URL into the body of a POST request. The grant_type , client_id , client_secret and redirect_uri must also be included in the POST body. The client makes a POST request to the /oauth/token endpoint to retrieve an access_token and refresh_token . foo@bar:~$ curl -X POST -d \"grant_type=authorization_code&code=ae4d1381cc67def1c10dc88a19af6ac30d7b5959&client_id=farmos_development&redirect_uri=http://localhost/api/authorized\" http://localhost/oauth/token {\"access_token\":\"3f9212c4a6656f1cd1304e47307927a7c224abb0\",\"expires_in\":\"10\",\"token_type\":\"Bearer\",\"scope\":\"user_access\",\"refresh_token\":\"292810b04d688bfb5c3cee28e45637ec8ef1dd9e\"} Fourth : the client sends the access token in the request header to access protected resources. The header is an Authorization header with a Bearer token: Authorization: Bearer access_token foo@bar:~$ curl --header \"Authorization: Bearer b872daf5827a75495c8194c6bfa4f90cf46c143e\" http://localhost/farm.json {\"name\":\"farmos-server\",\"url\":\"http:\\/\\/localhost\",\"api_version\":\"1.1\",\"user\":{\"uid\":\"1\",\"name\":\"admin\", ....","title":"Authorization Code Grant"},{"location":"development/api/authentication/#password-credentials-grant","text":"NOTE: Only use the Password Grant if the client can be trusted with a farmOS username and password (this is considered 1st party ). The Password Credentials Grant uses a farmOS username and password to retrieve an access_token and refresh_token in one step. For the user, this is the simplest type of authorization. Because the client can be trusted with their farmOS Credentials, a users username and password can be collected directly into a login form within the client application. These credentials are then used (not stored) to request tokens which are used for authentication with the farmOS server and retrieving data. Requesting protected resources is a two step process: First , the client sends a POST request to the farmOS server /oauth/token endpoint with grant_type set to password and a username and password included in the request body. $ curl -X POST -d \"grant_type=password&username=username&password=test&client_id=farm&scope=user_access\" http://localhost/oauth/token {\"access_token\":\"e69c60dea3f5c59c95863928fa6fb860d3506fe9\",\"expires_in\":\"300\",\"token_type\":\"Bearer\",\"scope\":\"user_access\",\"refresh_token\":\"cead7d46d18d74daea83f114bc0b512ec4cc31c3\"} second , the client sends the access_token in the request header to access protected resources. The header is an Authorization header with a Bearer token: Authorization: Bearer access_token foo@bar:~$ curl --header \"Authorization: Bearer e69c60dea3f5c59c95863928fa6fb860d3506fe9\" http://localhost/farm.json {\"name\":\"farmos-server\",\"url\":\"http:\\/\\/localhost\",\"api_version\":\"1.1\",\"user\":{\"uid\":\"1\",\"name\":\"admin\", ....","title":"Password Credentials Grant"},{"location":"development/api/authentication/#refreshing-tokens","text":"The refresh_token can be used to retrieve a new access_token if the token has expired. It is a one step process: The client sends an authenticated request to the /oauth/token endpoint with grant_type set to refresh_token and includes the refresh_token , client_id and client_secret in the request body. foo@bar:~$ curl -X POST -H 'Authorization: Bearer ad52c04d26c1002084501d28b59196996f0bd93f' -d 'refresh_token=52e7a0e12e8ddd08b155b3b3ee385687fef01664&grant_type=refresh_token&client_id=farmos_api_client&client_secret=client_secret' http://localhost/oauth/token {\"access_token\":\"acdbfabb736e42aa301b50fdda95d6b7fd3e7e14\",\"expires_in\":\"300\",\"token_type\":\"Bearer\",\"scope\":\"user_access\",\"refresh_token\":\"b73f4744840498a26f43447d8cf755238bfd391a\"} The server responds with an access_token and refresh_token that can be used in future requests. The previous access_token and refresh_token will no longer work.","title":"Refreshing Tokens"},{"location":"development/api/changes/","text":"API Changes \u00b6 2.x vs 1.x \u00b6 farmOS 1.x used the RESTful Web Services module, which provided API endpoints for each entity type (asset, log, taxonomy term, etc). farmOS 2.x uses the new JSON:API module included with Drupal core, which follows the JSON:API specification for defining API resources. The root API endpoint is /api . JSON Schema \u00b6 farmOS 2.x also provides JSON Schema information about all available resources. The root endpoint for schema information is /api/schema . In farmOS 1.x, the /farm.json endpoint provided similar information in the resources property. This has been removed in favor of JSON Schema. Farm info endpoint \u00b6 In farmOS 1.x, an informational API endpoint was provided at /farm.json . This included various information describing the farmOS server configuration, authenticated user, installed languages and available entity types and bundles. This information was provided as either a simple value or a JSON object: { \"name\": \"My Farm\", \"url\": \"https://myfarm.mydomain.com\", \"api_version\": \"1.0\", \"system_of_measurement\": \"metric\", \"user\": { ... }, \"languages\": { ... }, \"resources\": { ... }, \"metrics\": { ... } } In farmOS 2.x, a root /api endpoint either provides this information, or is a gateway to this information. The simple values previously available from /farm.json are now provided in the meta.farm object at /api : { \"jsonapi\":{ ... }, \"data\":[], \"meta\":{ \"links\":{ \"me\":{ \"meta\":{ \"id\":\"7b2af019-3191-40ca-b221-616f9a365722\" }, \"href\":\"http://localhost/api/user/user/7b2af019-3191-40ca-b221-616f9a365722\" } }, \"farm\":{ \"name\":\"My farm name\", \"url\":\"http://localhost\", \"version\":\"2.x\", \"system_of_measurement\": \"metric\" } }, \"links\":{ ... } } The resources object has been replaced with the links object that describes all the available resource types and their endpoints. Information previously provided in the other JSON objects are now available as standalone resources at their respective endpoints: user - /api/user/user The authenticated user's ID is included in the meta.links.me object with a link to the user's resource. The user's attributes, such as name and language, can be retrieved from that endpoint. languages - /api/configurable_language/configurable_language Resource endpoints \u00b6 In farmOS 1.x, API endpoints for each entity type were available at /[entity_type].json . For example: /log.json In farmOS 2.x, a root /api endpoint is provided, with a links object that describes all the available resource types and their endpoints. These follow a URL pattern of /api/[entity-type]/[bundle] . For example: /api/log/activity \"Bundles\" are \"sub-types\" that can have different sets (bundles) of fields on them. For example, a \"Seeding Log\" and a \"Harvest Log\" will collect different information, but both are \"Logs\" (events). To illustrate the difference between 1.x and 2.x, here are the endpoints for retrieving all Activity logs. farmOS 1.x: /log.json?type=farm_activity farmOS 2.x: /api/log/activity IDs \u00b6 farmOS 2.x assigns UUIDs (universally unique identifiers) to all resources, and uses them in the API. This differs from farmOS 1.x, which used the integer IDs directly from the auto-incrementing database table that the record was pulled from. The benefit of UUIDs is they are guaranteed to be unique across multiple farmOS databases, whereas the old IDs were not. The internal integer IDs are not exposed via the API, so all code that needs to integrate should use the new UUIDs instead. Also note that the migration from farmOS 1.x to 2.x does not preserve the internal integer IDs, so they may be different after migrating to 2.x. Record structure \u00b6 JSON:API has some rules about how records are structured that differ from farmOS 1.x. These rules make the API more explicit. In farmOS 1.x, all the fields/properties of a record were on the same level. For example, a simple observation log looked like this: { \"id\": \"5\" \"type\": \"farm_observation\", \"name\": \"Test observation\", \"timestamp\": \"1526584271\", \"asset\": [ { \"resource\": \"farm_asset\", \"id\": \"123\" } ] } In farmOS 2.x, JSON:API dictates that the \"attributes\" and \"relationships\" of a record be explicitly declared under attributes and relationships properties in the JSON. The same record in farmOS 2.x looks like: { \"id\": \"9bc49ffd-76e8-4f86-b811-b721cb771327\" \"type\": \"log--observation\", \"attributes\": { \"name\": \"Test observation\", \"timestamp\": \"1526584271\", }, \"relationships\": { \"asset\": { \"data\": [ { \"type\": \"asset--animal\", \"id\": \"75116e3e-c45e-431d-8b58-1fce6bb315cf\", } ] } } } Filtering \u00b6 The URL query parameters for filtering results have a different syntax in 2.x. Refer to the Drupal.org JSON:API Filtering documentation for more information. To illustrate, this is how to filter activity logs by their completed status: farmOS 1.x: /log.json?type=activity&done=1 farmOS 2.x: /api/log/activity?filter[status]=complete Text format \u00b6 Long text fields (like notes ) include value and format sub-properties, where value is the text value, and format is the \"Text format\" to use when displaying the text. This is used to filter user-supplied text, to only allow certain HTML tags (filtering out potential XSS vulnerabilities), convert URLs to links, etc. This works the same in farmOS 2.x, but the default format has changed from farm_format to default . Logs \u00b6 Log types \u00b6 The farm_ prefix has been dropped from all log type names. For example, in farmOS 1.x an Activity log was farm_activity , and in farmOS 2.x it is simply activity . Additionally, the \"Soil test\" and \"Water test\" log types have been merged into a single \"Lab test\" log type. Below is the full list of log types in farmOS 1.x and their new names in 2.x: farm_activity -> activity farm_harvest -> harvest farm_input -> input farm_maintenance -> maintenance farm_medical -> medical farm_observation -> observation farm_purchase -> purchase farm_sale -> sale farm_seeding -> seeding farm_soil_test -> lab_test farm_transplanting -> transplanting farm_water_test -> lab_test Log fields \u00b6 Log field names are largely unchanged, with a few exceptions (note that new fields are not listed here): area -> location (See \"Areas\" below) date_purchase -> purchase_date done -> status (see \"Log status\" below) files -> file flags -> flag geofield -> geometry images -> image input_method -> method input_source -> source log_category -> category log_owner -> owner seed_source -> source soil_lab -> lab water_lab -> lab quantity (see \"Quantities\" below) See also \"Text format\" above for information about the changes to the format parameter of long text fields. Log status \u00b6 In farmOS 1.x, logs had a boolean property called done which was either 1 (done) or 0 (not done). In 2.x, the done property has changed to status , and can be set to either done or pending . Additional states may be added in the future. Assets \u00b6 Asset records in farmOS 1.x had an entity type of farm_asset . In farmOS 2.x, the farm_ prefix has been dropped. The entity type is now simply asset . Asset types \u00b6 Asset type names are largely unchanged, with one notable exception: the \"Planting\" asset type has been renamed to \"Plant\". Below is the full list of asset types in farmOS 1.x and their new names in 2.x: animal (unchanged) compost (unchanged) equipment (unchanged) group (unchanged) planting -> plant sensor (unchanged) Asset fields \u00b6 Asset field names are largely unchanged, with a few exceptions (note that new fields are not listed here): animal_castrated -> is_castrated animal_nicknames -> nickname animal_sex -> sex animal_tag -> id_tag archived -> status and archived (see \"Asset status\" below) crop -> plant_type date -> birthdate (on animal assets) description -> notes (see also \"Text format\" above) flags -> flag files -> file images -> image Asset status \u00b6 In farmOS 1.x, assets had a property called archived which was either 0 , which indicated that the asset was active, or a timestamp that recorded when the asset was archived. In farmOS 2.x, these have been split into two separate fields: status - The status of the asset (either active or archived ). archived - The timestamp when the asset was archived. This will be empty if the asset is active. Taxonomies \u00b6 farmOS 2.x continues to use Drupal's core taxonomy_term entities to represent vocabularies of terms. The vocabulary machine names have changed, to drop the farm_ prefix, and to standardize plurality. farm_animal_types -> animal_type farm_areas has been removed (see \"Areas\" below) farm_log_categories -> log_category farm_materials -> material farm_season -> season farm_crops -> plant_type farm_crop_families -> crop_family farm_quantity_units -> unit Areas \u00b6 farmOS 2.x had the concept of \"Areas\" for representing places/locations. These were taxonomy terms in the farm_areas vocabulary. In farmOS 2.x, these areas are migrated to new asset types, and any asset can now be designated as a \"location\". New asset types are provided, including \"Land\", \"Structure\", and \"Water\", which have the \"location\" designation by default. Additional types can be provided by modules. Because any asset can be a location, some new fields are available on assets, including: is_location - Boolean indicating whether or not other assets can be moved to this asset. is_fixed - Boolean indicating that the asset has a fixed geometry and therefore does not move. intrinsic_geometry - A geofield representing the intrinsic geometry of \"fixed\" assets. Additionally, two \"computed\" fields are available on all assets, which provide quick access to the asset's current location and geometry, regardless of whether or not it is \"fixed\": geometry - The asset's current geometry. This will be the same as the intrinsic_geometry for \"fixed\" assets. Otherwise, it will mirror the geometry of the asset's most recent movement log. location - The asset's current location (an asset reference). This will always be empty for \"fixed\" assets. Otherwise, it will mirror the location reference field of the asset's most recent movement log. Quantities \u00b6 In farmOS 1.x, log quantities were saved within separate Field Collection entities. farmOS used the RESTful Web Services Field Collection module to hide the fact that these were separate entities, allowing their field to be accessed and modified in the same request to the host entity. In farmOS 2.x, quantities are represented as quantity entities. These are referenced under a log's relationships in JSON:API, and have a JSON:API resource name of quantity--quantity . In order to add a quantity to a new or existing log, they must be created in a separate API request before they can be referenced by the log. Quantities still have measure , value , unit and label fields.","title":"Changes"},{"location":"development/api/changes/#api-changes","text":"","title":"API Changes"},{"location":"development/api/changes/#2x-vs-1x","text":"farmOS 1.x used the RESTful Web Services module, which provided API endpoints for each entity type (asset, log, taxonomy term, etc). farmOS 2.x uses the new JSON:API module included with Drupal core, which follows the JSON:API specification for defining API resources. The root API endpoint is /api .","title":"2.x vs 1.x"},{"location":"development/api/changes/#json-schema","text":"farmOS 2.x also provides JSON Schema information about all available resources. The root endpoint for schema information is /api/schema . In farmOS 1.x, the /farm.json endpoint provided similar information in the resources property. This has been removed in favor of JSON Schema.","title":"JSON Schema"},{"location":"development/api/changes/#farm-info-endpoint","text":"In farmOS 1.x, an informational API endpoint was provided at /farm.json . This included various information describing the farmOS server configuration, authenticated user, installed languages and available entity types and bundles. This information was provided as either a simple value or a JSON object: { \"name\": \"My Farm\", \"url\": \"https://myfarm.mydomain.com\", \"api_version\": \"1.0\", \"system_of_measurement\": \"metric\", \"user\": { ... }, \"languages\": { ... }, \"resources\": { ... }, \"metrics\": { ... } } In farmOS 2.x, a root /api endpoint either provides this information, or is a gateway to this information. The simple values previously available from /farm.json are now provided in the meta.farm object at /api : { \"jsonapi\":{ ... }, \"data\":[], \"meta\":{ \"links\":{ \"me\":{ \"meta\":{ \"id\":\"7b2af019-3191-40ca-b221-616f9a365722\" }, \"href\":\"http://localhost/api/user/user/7b2af019-3191-40ca-b221-616f9a365722\" } }, \"farm\":{ \"name\":\"My farm name\", \"url\":\"http://localhost\", \"version\":\"2.x\", \"system_of_measurement\": \"metric\" } }, \"links\":{ ... } } The resources object has been replaced with the links object that describes all the available resource types and their endpoints. Information previously provided in the other JSON objects are now available as standalone resources at their respective endpoints: user - /api/user/user The authenticated user's ID is included in the meta.links.me object with a link to the user's resource. The user's attributes, such as name and language, can be retrieved from that endpoint. languages - /api/configurable_language/configurable_language","title":"Farm info endpoint"},{"location":"development/api/changes/#resource-endpoints","text":"In farmOS 1.x, API endpoints for each entity type were available at /[entity_type].json . For example: /log.json In farmOS 2.x, a root /api endpoint is provided, with a links object that describes all the available resource types and their endpoints. These follow a URL pattern of /api/[entity-type]/[bundle] . For example: /api/log/activity \"Bundles\" are \"sub-types\" that can have different sets (bundles) of fields on them. For example, a \"Seeding Log\" and a \"Harvest Log\" will collect different information, but both are \"Logs\" (events). To illustrate the difference between 1.x and 2.x, here are the endpoints for retrieving all Activity logs. farmOS 1.x: /log.json?type=farm_activity farmOS 2.x: /api/log/activity","title":"Resource endpoints"},{"location":"development/api/changes/#ids","text":"farmOS 2.x assigns UUIDs (universally unique identifiers) to all resources, and uses them in the API. This differs from farmOS 1.x, which used the integer IDs directly from the auto-incrementing database table that the record was pulled from. The benefit of UUIDs is they are guaranteed to be unique across multiple farmOS databases, whereas the old IDs were not. The internal integer IDs are not exposed via the API, so all code that needs to integrate should use the new UUIDs instead. Also note that the migration from farmOS 1.x to 2.x does not preserve the internal integer IDs, so they may be different after migrating to 2.x.","title":"IDs"},{"location":"development/api/changes/#record-structure","text":"JSON:API has some rules about how records are structured that differ from farmOS 1.x. These rules make the API more explicit. In farmOS 1.x, all the fields/properties of a record were on the same level. For example, a simple observation log looked like this: { \"id\": \"5\" \"type\": \"farm_observation\", \"name\": \"Test observation\", \"timestamp\": \"1526584271\", \"asset\": [ { \"resource\": \"farm_asset\", \"id\": \"123\" } ] } In farmOS 2.x, JSON:API dictates that the \"attributes\" and \"relationships\" of a record be explicitly declared under attributes and relationships properties in the JSON. The same record in farmOS 2.x looks like: { \"id\": \"9bc49ffd-76e8-4f86-b811-b721cb771327\" \"type\": \"log--observation\", \"attributes\": { \"name\": \"Test observation\", \"timestamp\": \"1526584271\", }, \"relationships\": { \"asset\": { \"data\": [ { \"type\": \"asset--animal\", \"id\": \"75116e3e-c45e-431d-8b58-1fce6bb315cf\", } ] } } }","title":"Record structure"},{"location":"development/api/changes/#filtering","text":"The URL query parameters for filtering results have a different syntax in 2.x. Refer to the Drupal.org JSON:API Filtering documentation for more information. To illustrate, this is how to filter activity logs by their completed status: farmOS 1.x: /log.json?type=activity&done=1 farmOS 2.x: /api/log/activity?filter[status]=complete","title":"Filtering"},{"location":"development/api/changes/#text-format","text":"Long text fields (like notes ) include value and format sub-properties, where value is the text value, and format is the \"Text format\" to use when displaying the text. This is used to filter user-supplied text, to only allow certain HTML tags (filtering out potential XSS vulnerabilities), convert URLs to links, etc. This works the same in farmOS 2.x, but the default format has changed from farm_format to default .","title":"Text format"},{"location":"development/api/changes/#logs","text":"","title":"Logs"},{"location":"development/api/changes/#log-types","text":"The farm_ prefix has been dropped from all log type names. For example, in farmOS 1.x an Activity log was farm_activity , and in farmOS 2.x it is simply activity . Additionally, the \"Soil test\" and \"Water test\" log types have been merged into a single \"Lab test\" log type. Below is the full list of log types in farmOS 1.x and their new names in 2.x: farm_activity -> activity farm_harvest -> harvest farm_input -> input farm_maintenance -> maintenance farm_medical -> medical farm_observation -> observation farm_purchase -> purchase farm_sale -> sale farm_seeding -> seeding farm_soil_test -> lab_test farm_transplanting -> transplanting farm_water_test -> lab_test","title":"Log types"},{"location":"development/api/changes/#log-fields","text":"Log field names are largely unchanged, with a few exceptions (note that new fields are not listed here): area -> location (See \"Areas\" below) date_purchase -> purchase_date done -> status (see \"Log status\" below) files -> file flags -> flag geofield -> geometry images -> image input_method -> method input_source -> source log_category -> category log_owner -> owner seed_source -> source soil_lab -> lab water_lab -> lab quantity (see \"Quantities\" below) See also \"Text format\" above for information about the changes to the format parameter of long text fields.","title":"Log fields"},{"location":"development/api/changes/#log-status","text":"In farmOS 1.x, logs had a boolean property called done which was either 1 (done) or 0 (not done). In 2.x, the done property has changed to status , and can be set to either done or pending . Additional states may be added in the future.","title":"Log status"},{"location":"development/api/changes/#assets","text":"Asset records in farmOS 1.x had an entity type of farm_asset . In farmOS 2.x, the farm_ prefix has been dropped. The entity type is now simply asset .","title":"Assets"},{"location":"development/api/changes/#asset-types","text":"Asset type names are largely unchanged, with one notable exception: the \"Planting\" asset type has been renamed to \"Plant\". Below is the full list of asset types in farmOS 1.x and their new names in 2.x: animal (unchanged) compost (unchanged) equipment (unchanged) group (unchanged) planting -> plant sensor (unchanged)","title":"Asset types"},{"location":"development/api/changes/#asset-fields","text":"Asset field names are largely unchanged, with a few exceptions (note that new fields are not listed here): animal_castrated -> is_castrated animal_nicknames -> nickname animal_sex -> sex animal_tag -> id_tag archived -> status and archived (see \"Asset status\" below) crop -> plant_type date -> birthdate (on animal assets) description -> notes (see also \"Text format\" above) flags -> flag files -> file images -> image","title":"Asset fields"},{"location":"development/api/changes/#asset-status","text":"In farmOS 1.x, assets had a property called archived which was either 0 , which indicated that the asset was active, or a timestamp that recorded when the asset was archived. In farmOS 2.x, these have been split into two separate fields: status - The status of the asset (either active or archived ). archived - The timestamp when the asset was archived. This will be empty if the asset is active.","title":"Asset status"},{"location":"development/api/changes/#taxonomies","text":"farmOS 2.x continues to use Drupal's core taxonomy_term entities to represent vocabularies of terms. The vocabulary machine names have changed, to drop the farm_ prefix, and to standardize plurality. farm_animal_types -> animal_type farm_areas has been removed (see \"Areas\" below) farm_log_categories -> log_category farm_materials -> material farm_season -> season farm_crops -> plant_type farm_crop_families -> crop_family farm_quantity_units -> unit","title":"Taxonomies"},{"location":"development/api/changes/#areas","text":"farmOS 2.x had the concept of \"Areas\" for representing places/locations. These were taxonomy terms in the farm_areas vocabulary. In farmOS 2.x, these areas are migrated to new asset types, and any asset can now be designated as a \"location\". New asset types are provided, including \"Land\", \"Structure\", and \"Water\", which have the \"location\" designation by default. Additional types can be provided by modules. Because any asset can be a location, some new fields are available on assets, including: is_location - Boolean indicating whether or not other assets can be moved to this asset. is_fixed - Boolean indicating that the asset has a fixed geometry and therefore does not move. intrinsic_geometry - A geofield representing the intrinsic geometry of \"fixed\" assets. Additionally, two \"computed\" fields are available on all assets, which provide quick access to the asset's current location and geometry, regardless of whether or not it is \"fixed\": geometry - The asset's current geometry. This will be the same as the intrinsic_geometry for \"fixed\" assets. Otherwise, it will mirror the geometry of the asset's most recent movement log. location - The asset's current location (an asset reference). This will always be empty for \"fixed\" assets. Otherwise, it will mirror the location reference field of the asset's most recent movement log.","title":"Areas"},{"location":"development/api/changes/#quantities","text":"In farmOS 1.x, log quantities were saved within separate Field Collection entities. farmOS used the RESTful Web Services Field Collection module to hide the fact that these were separate entities, allowing their field to be accessed and modified in the same request to the host entity. In farmOS 2.x, quantities are represented as quantity entities. These are referenced under a log's relationships in JSON:API, and have a JSON:API resource name of quantity--quantity . In order to add a quantity to a new or existing log, they must be created in a separate API request before they can be referenced by the log. Quantities still have measure , value , unit and label fields.","title":"Quantities"},{"location":"development/environment/","text":"Getting started \u00b6 Follow these instructions to set up a local farmOS development environment. The only requirements are Docker and Docker Compose . 1. Set up Docker containers \u00b6 Run the following commands to create a farmOS directory and set up Docker containers for farmOS and PostgreSQL: mkdir farmOS && cd farmOS curl https://raw.githubusercontent.com/farmOS/farmOS/2.x/docker/docker-compose.development.yml -o docker-compose.yml docker-compose up -d 2. Install farmOS \u00b6 Open http://localhost in a browser and install farmOS with the following database credentials: Database type: PostgreSQL Database name: farm Database user: farm Database password: farm Advanced options > Host: db 3. Develop \u00b6 Open the www directory in your favorite IDE. Optional \u00b6 Configure private filesystem \u00b6 In order to upload files, a private file path must be configured. The following line must be added to www/web/sites/default/settings.php : $settings['file_private_path'] = '/opt/drupal/web/sites/default/private/files'; Configure debugger \u00b6 See Debugging . Enable HTTPS \u00b6 See HTTPS .","title":"Getting started"},{"location":"development/environment/#getting-started","text":"Follow these instructions to set up a local farmOS development environment. The only requirements are Docker and Docker Compose .","title":"Getting started"},{"location":"development/environment/#1-set-up-docker-containers","text":"Run the following commands to create a farmOS directory and set up Docker containers for farmOS and PostgreSQL: mkdir farmOS && cd farmOS curl https://raw.githubusercontent.com/farmOS/farmOS/2.x/docker/docker-compose.development.yml -o docker-compose.yml docker-compose up -d","title":"1. Set up Docker containers"},{"location":"development/environment/#2-install-farmos","text":"Open http://localhost in a browser and install farmOS with the following database credentials: Database type: PostgreSQL Database name: farm Database user: farm Database password: farm Advanced options > Host: db","title":"2. Install farmOS"},{"location":"development/environment/#3-develop","text":"Open the www directory in your favorite IDE.","title":"3. Develop"},{"location":"development/environment/#optional","text":"","title":"Optional"},{"location":"development/environment/#configure-private-filesystem","text":"In order to upload files, a private file path must be configured. The following line must be added to www/web/sites/default/settings.php : $settings['file_private_path'] = '/opt/drupal/web/sites/default/private/files';","title":"Configure private filesystem"},{"location":"development/environment/#configure-debugger","text":"See Debugging .","title":"Configure debugger"},{"location":"development/environment/#enable-https","text":"See HTTPS .","title":"Enable HTTPS"},{"location":"development/environment/code/","text":"Coding standards \u00b6 farmOS follows Drupal coding standards . The farmOS development Docker image comes pre-installed with PHP CodeSniffer for detecting code standard violations. The following command will run PHP CodeSniffer on all farmOS code: docker exec -it -u www-data farmos_www_1 phpcs /opt/drupal/web/profiles/farm If you see no output, then there are no issues. In some cases, code standard violations can be fixed automatically with phpcbf : docker exec -it -u www-data farmos_www_1 phpcbf /opt/drupal/web/profiles/farm","title":"Coding standards"},{"location":"development/environment/code/#coding-standards","text":"farmOS follows Drupal coding standards . The farmOS development Docker image comes pre-installed with PHP CodeSniffer for detecting code standard violations. The following command will run PHP CodeSniffer on all farmOS code: docker exec -it -u www-data farmos_www_1 phpcs /opt/drupal/web/profiles/farm If you see no output, then there are no issues. In some cases, code standard violations can be fixed automatically with phpcbf : docker exec -it -u www-data farmos_www_1 phpcbf /opt/drupal/web/profiles/farm","title":"Coding standards"},{"location":"development/environment/composer/","text":"Composer \u00b6 The farmOS development Docker image comes pre-installed with Composer , which is used for dependency management. Running Composer in Docker \u00b6 In order to run the composer command, you must use docker exec to run the command inside the farmOS container. docker exec -it -u www-data farmos_www_1 composer For example, the following will run the composer help command: docker exec -it -u www-data farmos_www_1 composer help' Warning : If composer update farmos/farmos is run, it will replace the Git repository in web/profiles/farm , discarding all changes/branches/remotes/etc. Common tasks \u00b6 Some common Composer tasks are documented here. Adding a module \u00b6 composer require drupal/[module] This will download the module into the web/modules/contrib directory, and add it to the root composer.json file. If the module is being added to the farmOS installation profile itself, you need to manually move the require line from the root composer.json to web/profiles/farm/composer.json and commit it to that repository. To install the module, use Drush . Notes \u00b6 Could not delete /var/www/html/web/sites/default/default.settings.php See https://www.drupal.org/docs/develop/using-composer/starting-a-site-using-drupal-composer-project-templates#s-troubleshooting-permission-issues-prevent-running-composer","title":"Composer"},{"location":"development/environment/composer/#composer","text":"The farmOS development Docker image comes pre-installed with Composer , which is used for dependency management.","title":"Composer"},{"location":"development/environment/composer/#running-composer-in-docker","text":"In order to run the composer command, you must use docker exec to run the command inside the farmOS container. docker exec -it -u www-data farmos_www_1 composer For example, the following will run the composer help command: docker exec -it -u www-data farmos_www_1 composer help' Warning : If composer update farmos/farmos is run, it will replace the Git repository in web/profiles/farm , discarding all changes/branches/remotes/etc.","title":"Running Composer in Docker"},{"location":"development/environment/composer/#common-tasks","text":"Some common Composer tasks are documented here.","title":"Common tasks"},{"location":"development/environment/composer/#adding-a-module","text":"composer require drupal/[module] This will download the module into the web/modules/contrib directory, and add it to the root composer.json file. If the module is being added to the farmOS installation profile itself, you need to manually move the require line from the root composer.json to web/profiles/farm/composer.json and commit it to that repository. To install the module, use Drush .","title":"Adding a module"},{"location":"development/environment/composer/#notes","text":"Could not delete /var/www/html/web/sites/default/default.settings.php See https://www.drupal.org/docs/develop/using-composer/starting-a-site-using-drupal-composer-project-templates#s-troubleshooting-permission-issues-prevent-running-composer","title":"Notes"},{"location":"development/environment/debug/","text":"Debugging \u00b6 The farmOS development Docker image comes pre-installed with XDebug 3, which allows debugger connections on port 9003. In order to connect to it, the XDEBUG_CONFIG environment variable must be used to configure XDebug's client_host setting with the Docker container's \"Gateway\" IP address. With the containers running, this command will print the gateway IP: docker inspect farmos_www_1 | grep -o '\"Gateway\": \".*\\..*\\..*\\..*\"' Edit docker-compose.yml and enter the gateway IP in the XDEBUG_CONFIG environment variable. For example: environment: XDEBUG_MODE: debug XDEBUG_CONFIG: client_host=192.168.128.1 Restart the Docker containers for this change to take affect. docker-compose restart Note : If the Docker containers are removed and recreated, the IP address may change, and you will need to repeat these steps to reconfigure it. PHPStorm \u00b6 If you are using the PHPStorm IDE, with the configuration above in place, enable the \"Start listening for PHP Debug Connections\" option. Add a breakpoint in your code, load the page in your browser, and you should see a prompt appear in PHPStorm that will begin the debugging session and pause execution at your breakpoint. Drush + PHPStorm \u00b6 Debugging code that is run via Drush commands requires additional configuration. Add an XDEBUG_SESSION environment variable with a value of PHPSTORM , and a PHP_IDE_CONFIG environment variable with a value of serverName=localhost , as follows: environment: XDEBUG_MODE: debug XDEBUG_CONFIG: client_host=192.168.128.1 XDEBUG_SESSION: PHPSTORM PHP_IDE_CONFIG: serverName=localhost Run a drush command and a prompt should appear in PHPStorm. You will need to map the path to Drush ( vendor/drush ) in the PHPStorm debugger config. Then you can set breakpoints in the Drush code you want to test.","title":"Debugging"},{"location":"development/environment/debug/#debugging","text":"The farmOS development Docker image comes pre-installed with XDebug 3, which allows debugger connections on port 9003. In order to connect to it, the XDEBUG_CONFIG environment variable must be used to configure XDebug's client_host setting with the Docker container's \"Gateway\" IP address. With the containers running, this command will print the gateway IP: docker inspect farmos_www_1 | grep -o '\"Gateway\": \".*\\..*\\..*\\..*\"' Edit docker-compose.yml and enter the gateway IP in the XDEBUG_CONFIG environment variable. For example: environment: XDEBUG_MODE: debug XDEBUG_CONFIG: client_host=192.168.128.1 Restart the Docker containers for this change to take affect. docker-compose restart Note : If the Docker containers are removed and recreated, the IP address may change, and you will need to repeat these steps to reconfigure it.","title":"Debugging"},{"location":"development/environment/debug/#phpstorm","text":"If you are using the PHPStorm IDE, with the configuration above in place, enable the \"Start listening for PHP Debug Connections\" option. Add a breakpoint in your code, load the page in your browser, and you should see a prompt appear in PHPStorm that will begin the debugging session and pause execution at your breakpoint.","title":"PHPStorm"},{"location":"development/environment/debug/#drush-phpstorm","text":"Debugging code that is run via Drush commands requires additional configuration. Add an XDEBUG_SESSION environment variable with a value of PHPSTORM , and a PHP_IDE_CONFIG environment variable with a value of serverName=localhost , as follows: environment: XDEBUG_MODE: debug XDEBUG_CONFIG: client_host=192.168.128.1 XDEBUG_SESSION: PHPSTORM PHP_IDE_CONFIG: serverName=localhost Run a drush command and a prompt should appear in PHPStorm. You will need to map the path to Drush ( vendor/drush ) in the PHPStorm debugger config. Then you can set breakpoints in the Drush code you want to test.","title":"Drush + PHPStorm"},{"location":"development/environment/docker/","text":"Docker \u00b6 Docker build arguments \u00b6 The farmOS Docker images allow certain variables to be overridden at image build time using the --build-arg parameter of docker build . Available arguments and their default values are described below: FARMOS_REPO - The farmOS Git repository URL. Default: https://github.com/farmOS/farmOS.git FARMOS_VERSION - The farmOS Git branch/tag/commit to check out. Default: 2.x PROJECT_REPO - The farmOS Composer project Git repository URL. Default: https://github.com/farmOS/composer-project.git PROJECT_VERSION - The farmOS Composer project Git branch/tag/commit to check out. Default: 2.x The 2.x-dev image also provides the following: WWW_DATA_ID - The ID to use for the www-data user and group inside the image. Setting this to the ID of the developer's user on the host machine allows Composer to create files owned by www-data inside the container, while keeping those files editable by the developer outside of the container. If your user ID is not 1000 , build the image with: --build-arg WWW_DATA_ID=$(id -u) Default: 1000","title":"Docker"},{"location":"development/environment/docker/#docker","text":"","title":"Docker"},{"location":"development/environment/docker/#docker-build-arguments","text":"The farmOS Docker images allow certain variables to be overridden at image build time using the --build-arg parameter of docker build . Available arguments and their default values are described below: FARMOS_REPO - The farmOS Git repository URL. Default: https://github.com/farmOS/farmOS.git FARMOS_VERSION - The farmOS Git branch/tag/commit to check out. Default: 2.x PROJECT_REPO - The farmOS Composer project Git repository URL. Default: https://github.com/farmOS/composer-project.git PROJECT_VERSION - The farmOS Composer project Git branch/tag/commit to check out. Default: 2.x The 2.x-dev image also provides the following: WWW_DATA_ID - The ID to use for the www-data user and group inside the image. Setting this to the ID of the developer's user on the host machine allows Composer to create files owned by www-data inside the container, while keeping those files editable by the developer outside of the container. If your user ID is not 1000 , build the image with: --build-arg WWW_DATA_ID=$(id -u) Default: 1000","title":"Docker build arguments"},{"location":"development/environment/documentation/","text":"Documentation \u00b6 In addition to the code for farmOS, this repository includes the source files of the documentation which is hosted at http://docs.farmos.org . It uses mkdocs to convert simple markdown files into static HTML files. To get started contributing to the farmOS 2.x documentation, fork farmOS on Github. Then install mkdocs and clone this repo: $ brew install python # For OSX users $ sudo apt-get install python-pip # For Debian/Ubuntu users $ sudo pip install mkdocs mkdocs-material $ git clone https://github.com/farmOS/farmOS.git farmOS $ cd farmOS $ git checkout 2.x $ git remote add sandbox git@github.com:<username>/farmOS.git $ mkdocs serve Your local farmOS 2.x documentation site should now be available for browsing: http://127.0.0.1:8000/. When you find a typo, an error, unclear or missing explanations or instructions, hit ctrl-c, to stop the server, and start editing. Find the page you\u2019d like to edit; everything is in the docs/ directory. Make your changes, commit and push them, and start a pull request: $ git checkout -b fix_typo # Create a new branch for your changes. ... # Make your changes. $ mkdocs build --clean; mkdocs serve # Go check your changes. $ git diff # Make sure there aren\u2019t any unintended changes. ... $ git commit -am \"Fixed typo.\" # Useful commit message are a good habit. $ git push sandbox fix_typo # Push your new branch up to your Github sandbox. Visit your fork on Github and start a Pull Request. For more information on writing and managing documentation with mkdocs, read the official mkdocs documentation: http://www.mkdocs.org","title":"Documentation"},{"location":"development/environment/documentation/#documentation","text":"In addition to the code for farmOS, this repository includes the source files of the documentation which is hosted at http://docs.farmos.org . It uses mkdocs to convert simple markdown files into static HTML files. To get started contributing to the farmOS 2.x documentation, fork farmOS on Github. Then install mkdocs and clone this repo: $ brew install python # For OSX users $ sudo apt-get install python-pip # For Debian/Ubuntu users $ sudo pip install mkdocs mkdocs-material $ git clone https://github.com/farmOS/farmOS.git farmOS $ cd farmOS $ git checkout 2.x $ git remote add sandbox git@github.com:<username>/farmOS.git $ mkdocs serve Your local farmOS 2.x documentation site should now be available for browsing: http://127.0.0.1:8000/. When you find a typo, an error, unclear or missing explanations or instructions, hit ctrl-c, to stop the server, and start editing. Find the page you\u2019d like to edit; everything is in the docs/ directory. Make your changes, commit and push them, and start a pull request: $ git checkout -b fix_typo # Create a new branch for your changes. ... # Make your changes. $ mkdocs build --clean; mkdocs serve # Go check your changes. $ git diff # Make sure there aren\u2019t any unintended changes. ... $ git commit -am \"Fixed typo.\" # Useful commit message are a good habit. $ git push sandbox fix_typo # Push your new branch up to your Github sandbox. Visit your fork on Github and start a Pull Request. For more information on writing and managing documentation with mkdocs, read the official mkdocs documentation: http://www.mkdocs.org","title":"Documentation"},{"location":"development/environment/drush/","text":"Drush \u00b6 The farmOS Docker image comes pre-installed with Drush , which provides shell commands for working with a Drupal installation. Running Drush in Docker \u00b6 In order to run the drush command, you must use docker exec to run the command inside the farmOS container. docker exec -it -u www-data farmos_www_1 drush For example, the following will run the drush cr command to rebuild caches: docker exec -it -u www-data farmos_www_1 drush cr Useful commands \u00b6 Some useful Drush commands are documented here. Rebuild caches \u00b6 drush cr Install a module \u00b6 drush en log","title":"Drush"},{"location":"development/environment/drush/#drush","text":"The farmOS Docker image comes pre-installed with Drush , which provides shell commands for working with a Drupal installation.","title":"Drush"},{"location":"development/environment/drush/#running-drush-in-docker","text":"In order to run the drush command, you must use docker exec to run the command inside the farmOS container. docker exec -it -u www-data farmos_www_1 drush For example, the following will run the drush cr command to rebuild caches: docker exec -it -u www-data farmos_www_1 drush cr","title":"Running Drush in Docker"},{"location":"development/environment/drush/#useful-commands","text":"Some useful Drush commands are documented here.","title":"Useful commands"},{"location":"development/environment/drush/#rebuild-caches","text":"drush cr","title":"Rebuild caches"},{"location":"development/environment/drush/#install-a-module","text":"drush en log","title":"Install a module"},{"location":"development/environment/https/","text":"Local HTTPS \u00b6 Some development testing is easier with farmOS on an https:// endpoint. A separate Nginx reverse proxy provides a simple way to achieve this without any changes to the Apache configuration that runs in the farmOS Docker container. First, generate self-signed SSL certificate files into an ssl directory, from the directory that your docker-compose.yml file is in: mkdir ssl openssl req -newkey rsa:4096 -x509 -sha256 -nodes -out ssl/openssl.crt -keyout ssl/openssl.key` Create a file called nginx.conf alongside docker-compose.yml : events {} http { server { listen 80 default_server; listen [::]:80 default_server; server_name _; return 301 https://$host$request_uri; } server { server_name localhost; listen 443 ssl; ssl_certificate /etc/nginx/ssl/openssl.crt; ssl_certificate_key /etc/nginx/ssl/openssl.key; location / { proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-Host $http_host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; proxy_pass http://www; } } } Add the following lines to www/web/sites/default/settings.php : $settings['reverse_proxy'] = TRUE; $settings['reverse_proxy_addresses'] = [!empty($_SERVER['REMOTE_ADDR']) ?? NULL]; $settings['reverse_proxy_trusted_headers'] = \\Symfony\\Component\\HttpFoundation\\Request::HEADER_X_FORWARDED_ALL; Add the following service to your local docker-compose.yml file: proxy: image: nginx depends_on: - www ports: - '80:80' - '443:443' volumes: - './nginx.conf:/etc/nginx/nginx.conf' - './ssl:/etc/nginx/ssl' Also remove port 80 from the www service: ports: - '80:80' Finally, start the Docker services: docker-compose up farmOS is now accessible via https://localhost .","title":"HTTPS"},{"location":"development/environment/https/#local-https","text":"Some development testing is easier with farmOS on an https:// endpoint. A separate Nginx reverse proxy provides a simple way to achieve this without any changes to the Apache configuration that runs in the farmOS Docker container. First, generate self-signed SSL certificate files into an ssl directory, from the directory that your docker-compose.yml file is in: mkdir ssl openssl req -newkey rsa:4096 -x509 -sha256 -nodes -out ssl/openssl.crt -keyout ssl/openssl.key` Create a file called nginx.conf alongside docker-compose.yml : events {} http { server { listen 80 default_server; listen [::]:80 default_server; server_name _; return 301 https://$host$request_uri; } server { server_name localhost; listen 443 ssl; ssl_certificate /etc/nginx/ssl/openssl.crt; ssl_certificate_key /etc/nginx/ssl/openssl.key; location / { proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-Host $http_host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; proxy_pass http://www; } } } Add the following lines to www/web/sites/default/settings.php : $settings['reverse_proxy'] = TRUE; $settings['reverse_proxy_addresses'] = [!empty($_SERVER['REMOTE_ADDR']) ?? NULL]; $settings['reverse_proxy_trusted_headers'] = \\Symfony\\Component\\HttpFoundation\\Request::HEADER_X_FORWARDED_ALL; Add the following service to your local docker-compose.yml file: proxy: image: nginx depends_on: - www ports: - '80:80' - '443:443' volumes: - './nginx.conf:/etc/nginx/nginx.conf' - './ssl:/etc/nginx/ssl' Also remove port 80 from the www service: ports: - '80:80' Finally, start the Docker services: docker-compose up farmOS is now accessible via https://localhost .","title":"Local HTTPS"},{"location":"development/environment/postgresql/","text":"PostgreSQL \u00b6 The farmOS Docker image comes pre-installed with the PostgreSQL client psql command, which can be used to connect to the database and run queries from the command line. Open PostgreSQL prompt \u00b6 docker exec -it farmos_www_1 psql -h db -d farm -U farm Enter farm as the password.","title":"PostgreSQL"},{"location":"development/environment/postgresql/#postgresql","text":"The farmOS Docker image comes pre-installed with the PostgreSQL client psql command, which can be used to connect to the database and run queries from the command line.","title":"PostgreSQL"},{"location":"development/environment/postgresql/#open-postgresql-prompt","text":"docker exec -it farmos_www_1 psql -h db -d farm -U farm Enter farm as the password.","title":"Open PostgreSQL prompt"},{"location":"development/environment/tests/","text":"Automated tests \u00b6 The farmOS development Docker image comes pre-installed with all the dependencies necessary for running automated tests via PHPUnit . The following command will run all automated tests provided by farmOS: docker exec -it -u www-data farmos_www_1 phpunit --verbose --debug /opt/drupal/web/profiles/farm Tests from other projects/dependencies can be run in a similar fashion. For example, the following command will run all tests in the Log module: docker exec -it -u www-data farmos_www_1 phpunit --verbose --debug /opt/drupal/web/modules/log Faster testing without XDebug \u00b6 The instructions above will run tests with XDebug enabled which may be helpful for debugging , but is also slower. One way to avoid XDebug is to run the tests via the prod farmOS image. The automated tests which run upon Github check-in follow this strategy which is orchestrated via run-tests.yml and a docker-compose file like docker-compose.testing.pgsql.yml - corresponding files also exist for MariaDB and SQLite . Something similar can be accomplished locally by adding an additional container to one's dev environment using the farmos/farmos:2.x image and mounting the same volume from the dev container to /opt/drupal . In a docker-compose.yml based off docker-compose.development.yml , this might look like; test-runner: image: farmos/farmos:2.x volumes: - './www:/opt/drupal' The tests could then be run via docker-compose exec as follows; docker-compose exec -u www-data -T test-runner phpunit --verbose --debug /opt/drupal/web/profiles/farm Note: As described in the farmOS docker documentation , the dev docker container uses a different user id for the www-data user - by default 1000. Since that id differs from the default www-data user id for the prod image - 33 - the permissions of the files mounted to /opt/drupal will cause tests to fail. Solutions to this will be specific to a developers environment, but some approaches are outlined below; Build a docker image derived from farmos/farmos:2.x which sets the id of the www-data user to match that of the dev image by including RUN usermod -u ${WWW_DATA_ID} www-data && groupmod -g ${WWW_DATA_ID} www-data and passing WWW_DATA_ID as a build build-arg Before launching the tests, use chmod / chown / setfacl to modify the permissions of the files mounted to /opt/drupal such that user id 33 can access them Rebuild the dev docker image to also use 33 as the user id of the www-data user","title":"Automated tests"},{"location":"development/environment/tests/#automated-tests","text":"The farmOS development Docker image comes pre-installed with all the dependencies necessary for running automated tests via PHPUnit . The following command will run all automated tests provided by farmOS: docker exec -it -u www-data farmos_www_1 phpunit --verbose --debug /opt/drupal/web/profiles/farm Tests from other projects/dependencies can be run in a similar fashion. For example, the following command will run all tests in the Log module: docker exec -it -u www-data farmos_www_1 phpunit --verbose --debug /opt/drupal/web/modules/log","title":"Automated tests"},{"location":"development/environment/tests/#faster-testing-without-xdebug","text":"The instructions above will run tests with XDebug enabled which may be helpful for debugging , but is also slower. One way to avoid XDebug is to run the tests via the prod farmOS image. The automated tests which run upon Github check-in follow this strategy which is orchestrated via run-tests.yml and a docker-compose file like docker-compose.testing.pgsql.yml - corresponding files also exist for MariaDB and SQLite . Something similar can be accomplished locally by adding an additional container to one's dev environment using the farmos/farmos:2.x image and mounting the same volume from the dev container to /opt/drupal . In a docker-compose.yml based off docker-compose.development.yml , this might look like; test-runner: image: farmos/farmos:2.x volumes: - './www:/opt/drupal' The tests could then be run via docker-compose exec as follows; docker-compose exec -u www-data -T test-runner phpunit --verbose --debug /opt/drupal/web/profiles/farm Note: As described in the farmOS docker documentation , the dev docker container uses a different user id for the www-data user - by default 1000. Since that id differs from the default www-data user id for the prod image - 33 - the permissions of the files mounted to /opt/drupal will cause tests to fail. Solutions to this will be specific to a developers environment, but some approaches are outlined below; Build a docker image derived from farmos/farmos:2.x which sets the id of the www-data user to match that of the dev image by including RUN usermod -u ${WWW_DATA_ID} www-data && groupmod -g ${WWW_DATA_ID} www-data and passing WWW_DATA_ID as a build build-arg Before launching the tests, use chmod / chown / setfacl to modify the permissions of the files mounted to /opt/drupal such that user id 33 can access them Rebuild the dev docker image to also use 33 as the user id of the www-data user","title":"Faster testing without XDebug"},{"location":"development/environment/update/","text":"Updating local environment \u00b6 The following commands will update your local farmOS development environment. This approach avoids running composer commands because that is already done when the Docker image is built. Warning : This will replace everything except the profiles and sites directories. If you are developing farmOS core, this will ensure that your farmOS Git repository (inside profiles/farm ) will not be touched. If you are developing a custom module, make sure that it is in sites/all/modules , otherwise it will be deleted. PHPStorm : If you are using PHPStorm, you will also want to make sure the .idea folder is not destroyed during this process. If it is in the www directory, be sure to move that out before running rm -r www below, and restore it afterwards. It is recommended that you close PHPStorm during this process to avoid any project settings corruption. # Run these commands from the local directory that contains docker-compose.yml. # The Docker containers should be running. # Backup www volume, just in case. sudo tar -czf www.tar.gz www # Pull latest 2.x-dev Docker image. docker pull farmos/farmos:2.x-dev # Move directories. mv www/web/profiles ./profiles mv www/web/sites ./sites # Update codebase. docker-compose down rm -r www docker-compose up -d # Restore directories. sudo rm -rf www/web/profiles www/web/sites mv ./profiles www/web/profiles mv ./sites www/web/sites # Update farmOS profile. cd www/web/profiles/farm git checkout 2.x && git pull origin 2.x # Run Drupal database updates. docker-compose exec -u www-data www drush updb","title":"Updating"},{"location":"development/environment/update/#updating-local-environment","text":"The following commands will update your local farmOS development environment. This approach avoids running composer commands because that is already done when the Docker image is built. Warning : This will replace everything except the profiles and sites directories. If you are developing farmOS core, this will ensure that your farmOS Git repository (inside profiles/farm ) will not be touched. If you are developing a custom module, make sure that it is in sites/all/modules , otherwise it will be deleted. PHPStorm : If you are using PHPStorm, you will also want to make sure the .idea folder is not destroyed during this process. If it is in the www directory, be sure to move that out before running rm -r www below, and restore it afterwards. It is recommended that you close PHPStorm during this process to avoid any project settings corruption. # Run these commands from the local directory that contains docker-compose.yml. # The Docker containers should be running. # Backup www volume, just in case. sudo tar -czf www.tar.gz www # Pull latest 2.x-dev Docker image. docker pull farmos/farmos:2.x-dev # Move directories. mv www/web/profiles ./profiles mv www/web/sites ./sites # Update codebase. docker-compose down rm -r www docker-compose up -d # Restore directories. sudo rm -rf www/web/profiles www/web/sites mv ./profiles www/web/profiles mv ./sites www/web/sites # Update farmOS profile. cd www/web/profiles/farm git checkout 2.x && git pull origin 2.x # Run Drupal database updates. docker-compose exec -u www-data www drush updb","title":"Updating local environment"},{"location":"development/module/","text":"farmOS module development \u00b6 farmOS modules can be written to extend the capabilities of farmOS. This document describes how to get started with farmOS module development. For detailed documentation of Drupal development more generally, refer to the guide on drupal.org . Modules directory \u00b6 Modules should be placed in the modules directory of the server's document root, at the same level as the profiles directory, which contains the farm profile (farmOS). If you are using the farmOS Docker image, this will be: /var/opt/drupal/web/modules farmOS automatically puts Drupal module dependencies in modules/contrib . A good practice is to download farmOS-specific modules into modules/farm to keep them separate. You may also consider creating a modules/custom directory for custom modules that are specific to your farmOS instance. Namespacing \u00b6 A farmOS (Drupal) module must have a unique name consisting only of lowercase alphanumeric characters and underscores. This is used as a namespace throughout the module, and allows Drupal hook functions to be executed on behalf of your module. It is best practice to prefix all farmOS-specific module names with farm_ . For example, if you were to build a module that adds a new log type called irrigation , you might name it farm_irrigation . This serves to specify that this module is made to work with farmOS, and is not designed to be installed in other Drupal sites more generally. File structure \u00b6 A farmOS (Drupal) module only requires one file for it to be recognized as a module: [modulename].info.yml (where [modulename] is the module name). This info YML file contains the module's human readable name, description, dependency declarations, and other meta information about the module. A very simple example looks like this: mylogtype.info.yml : name: My log type description: Adds my new custom log type. type: module package: farmOS Contrib core_version_requirement: ^9 dependencies: - farm:farm_entity Other common files and directories in a module include: [modulename].module - Optional PHP file for Drupal hook implementations. config/install/*.yml - Configuration entities that will be installed with the module. config/optional/*.yml - Optional configuration entities that will only be installed if certain dependencies are met. src/* - PHP classes organized using the PSR-4 autoloading specification. tests/* - Automated tests for the module. Publishing \u00b6 If you want to share your module, consider publishing the repository so that it can be downloaded and installed by other farmOS users. farmOS.org maintains a list of community modules, and accepts new additions via pull requests . It is recommended that \"contributed\" farmOS modules be made available as a \"project\" on Drupal.org . This has two benefits: Projects can be included via Composer with: composer require drupal/mymodule Translations can be automatically managed and downloaded from Drupal's centralized localization server: localize.drupal.org License \u00b6 farmOS modules that are distributed to others must be licensed under the GNU General Public License, version 2 or later . For more information about farmOS and Drupal module licensing requirements, refer to Drupal.org Licensing .","title":"Getting started"},{"location":"development/module/#farmos-module-development","text":"farmOS modules can be written to extend the capabilities of farmOS. This document describes how to get started with farmOS module development. For detailed documentation of Drupal development more generally, refer to the guide on drupal.org .","title":"farmOS module development"},{"location":"development/module/#modules-directory","text":"Modules should be placed in the modules directory of the server's document root, at the same level as the profiles directory, which contains the farm profile (farmOS). If you are using the farmOS Docker image, this will be: /var/opt/drupal/web/modules farmOS automatically puts Drupal module dependencies in modules/contrib . A good practice is to download farmOS-specific modules into modules/farm to keep them separate. You may also consider creating a modules/custom directory for custom modules that are specific to your farmOS instance.","title":"Modules directory"},{"location":"development/module/#namespacing","text":"A farmOS (Drupal) module must have a unique name consisting only of lowercase alphanumeric characters and underscores. This is used as a namespace throughout the module, and allows Drupal hook functions to be executed on behalf of your module. It is best practice to prefix all farmOS-specific module names with farm_ . For example, if you were to build a module that adds a new log type called irrigation , you might name it farm_irrigation . This serves to specify that this module is made to work with farmOS, and is not designed to be installed in other Drupal sites more generally.","title":"Namespacing"},{"location":"development/module/#file-structure","text":"A farmOS (Drupal) module only requires one file for it to be recognized as a module: [modulename].info.yml (where [modulename] is the module name). This info YML file contains the module's human readable name, description, dependency declarations, and other meta information about the module. A very simple example looks like this: mylogtype.info.yml : name: My log type description: Adds my new custom log type. type: module package: farmOS Contrib core_version_requirement: ^9 dependencies: - farm:farm_entity Other common files and directories in a module include: [modulename].module - Optional PHP file for Drupal hook implementations. config/install/*.yml - Configuration entities that will be installed with the module. config/optional/*.yml - Optional configuration entities that will only be installed if certain dependencies are met. src/* - PHP classes organized using the PSR-4 autoloading specification. tests/* - Automated tests for the module.","title":"File structure"},{"location":"development/module/#publishing","text":"If you want to share your module, consider publishing the repository so that it can be downloaded and installed by other farmOS users. farmOS.org maintains a list of community modules, and accepts new additions via pull requests . It is recommended that \"contributed\" farmOS modules be made available as a \"project\" on Drupal.org . This has two benefits: Projects can be included via Composer with: composer require drupal/mymodule Translations can be automatically managed and downloaded from Drupal's centralized localization server: localize.drupal.org","title":"Publishing"},{"location":"development/module/#license","text":"farmOS modules that are distributed to others must be licensed under the GNU General Public License, version 2 or later . For more information about farmOS and Drupal module licensing requirements, refer to Drupal.org Licensing .","title":"License"},{"location":"development/module/entities/","text":"Entity types \u00b6 Assets, logs, plans, taxonomy terms, users, etc are all types of \"entities\" in farmOS/Drupal terminology. Entities can have sub-types called \"bundles\", which represent \"bundles of fields\". Some fields may be common across all bundles of a given entity type, and some fields may be bundle-specific. Adding asset, log, and plan types \u00b6 Asset types, log types, and plan types can be provided by adding two files to a module: An entity type config file (YAML), and: A bundle plugin class (PHP). For example, the \"Activity\" log type is provided as follows: config/install/log.type.activity.yml : langcode: en status: true dependencies: enforced: module: - farm_activity id: activity label: Activity description: '' name_pattern: 'Activity log [log:id]' workflow: log_default new_revision: true src/Plugin/Log/LogType/Activity.php : <?php namespace Drupal\\farm_activity\\Plugin\\Log\\LogType; use Drupal\\farm_entity\\Plugin\\Log\\LogType\\FarmLogType; /** * Provides the activity log type. * * @LogType( * id = \"activity\", * label = @Translation(\"Activity\"), * ) */ class Activity extends FarmLogType { } Bundle fields \u00b6 Bundles can declare field definitions in their plugin class via the buildFieldDefinitions() method. A farm_field.factory helper service is provided to make this easier. The Equipment asset type does this to add \"Manufacturer\", \"Model\", and \"Serial number\" fields: /** * {@inheritdoc} */ public function buildFieldDefinitions() { $fields = parent::buildFieldDefinitions(); $field_info = [ 'manufacturer' => [ 'type' => 'string', 'label' => $this->t('Manufacturer'), 'weight' => [ 'form' => -20, 'view' => -50, ], ], 'model' => [ 'type' => 'string', 'label' => $this->t('Model'), 'weight' => [ 'form' => -15, 'view' => -40, ], ], 'serial_number' => [ 'type' => 'string', 'label' => $this->t('Serial number'), 'weight' => [ 'form' => -10, 'view' => -30, ], ], ]; foreach ($field_info as $name => $info) { $fields[$name] = \\Drupal::service('farm_field.factory')->bundleFieldDefinition($info); } return $fields; } For more information, see Adding fields .","title":"Entities"},{"location":"development/module/entities/#entity-types","text":"Assets, logs, plans, taxonomy terms, users, etc are all types of \"entities\" in farmOS/Drupal terminology. Entities can have sub-types called \"bundles\", which represent \"bundles of fields\". Some fields may be common across all bundles of a given entity type, and some fields may be bundle-specific.","title":"Entity types"},{"location":"development/module/entities/#adding-asset-log-and-plan-types","text":"Asset types, log types, and plan types can be provided by adding two files to a module: An entity type config file (YAML), and: A bundle plugin class (PHP). For example, the \"Activity\" log type is provided as follows: config/install/log.type.activity.yml : langcode: en status: true dependencies: enforced: module: - farm_activity id: activity label: Activity description: '' name_pattern: 'Activity log [log:id]' workflow: log_default new_revision: true src/Plugin/Log/LogType/Activity.php : <?php namespace Drupal\\farm_activity\\Plugin\\Log\\LogType; use Drupal\\farm_entity\\Plugin\\Log\\LogType\\FarmLogType; /** * Provides the activity log type. * * @LogType( * id = \"activity\", * label = @Translation(\"Activity\"), * ) */ class Activity extends FarmLogType { }","title":"Adding asset, log, and plan types"},{"location":"development/module/entities/#bundle-fields","text":"Bundles can declare field definitions in their plugin class via the buildFieldDefinitions() method. A farm_field.factory helper service is provided to make this easier. The Equipment asset type does this to add \"Manufacturer\", \"Model\", and \"Serial number\" fields: /** * {@inheritdoc} */ public function buildFieldDefinitions() { $fields = parent::buildFieldDefinitions(); $field_info = [ 'manufacturer' => [ 'type' => 'string', 'label' => $this->t('Manufacturer'), 'weight' => [ 'form' => -20, 'view' => -50, ], ], 'model' => [ 'type' => 'string', 'label' => $this->t('Model'), 'weight' => [ 'form' => -15, 'view' => -40, ], ], 'serial_number' => [ 'type' => 'string', 'label' => $this->t('Serial number'), 'weight' => [ 'form' => -10, 'view' => -30, ], ], ]; foreach ($field_info as $name => $info) { $fields[$name] = \\Drupal::service('farm_field.factory')->bundleFieldDefinition($info); } return $fields; } For more information, see Adding fields .","title":"Bundle fields"},{"location":"development/module/fields/","text":"Fields \u00b6 Adding fields \u00b6 A module may add additional fields to assets, logs, and other entity types in farmOS. The following documents how to add fields to existing entity types. See Entity types to understand how to create new asset, log, and plan types with custom fields on them. Base fields \u00b6 If the field should be added to all bundles of a given entity type (eg: all log types), then they should be added as \"base fields\" via hook_entity_base_field_info() . A farm_field.factory helper service is provided to make this easier: <?php use Drupal\\Core\\Entity\\EntityTypeInterface; /** * Implements hook_entity_base_field_info(). */ function mymodule_entity_base_field_info(EntityTypeInterface $entity_type) { $fields = []; // Add a new string field to Log entities. if ($entity_type->id() == 'log') { $options = [ 'type' => 'string', 'label' => t('My new field'), 'description' => t('My field description.'), 'weight' => [ 'form' => 10, 'view' => 10, ], ]; $fields['myfield'] = \\Drupal::service('farm_field.factory')->baseFieldDefinition($options); } return $fields; } Bundle fields \u00b6 If the field should only be added to a single bundle (eg: only \"Input\" logs), then they should be added as \"bundle fields\" via hook_farm_entity_bundle_field_info() * * Note that this is a custom hook provided by farmOS, which may be deprecated in favor of a core Drupal hook in the future. See core issue: https://www.drupal.org/node/2346347 The format for bundle field definitions is identical to base field definitions (above), but the bundleFieldDefinition() method must be used instead of baseFieldDefinition() . <?php use Drupal\\Core\\Entity\\EntityTypeInterface; /** * Implements hook_farm_entity_bundle_field_info(). */ function mymodule_farm_entity_bundle_field_info(EntityTypeInterface $entity_type, $bundle) { $fields = []; // Add a new string field to Input Logs. if ($entity_type->id() == 'log' && $bundle == 'input') { $options = [ 'type' => 'string', 'label' => t('My new field'), 'description' => t('My field description.'), 'weight' => [ 'form' => 10, 'view' => 10, ], ]; $fields['myfield'] = \\Drupal::service('farm_field.factory')->bundleFieldDefinition($options); } return $fields; } Select options \u00b6 Certain fields on assets and logs include a list of options to select from. These include: Flags (on assets and logs) Monitor ( monitor ) Needs review ( needs_review ) Priority ( priority ) Land types (on Land assets) Property ( property ) Field ( field ) Bed ( bed ) Paddock ( paddock ) Landmark ( landmark ) Other ( other ) Structure types (on Structure assets) Building ( building ) Greenhouse ( greenhouse ) Lab test type (on Lab test logs) Soil test ( soil ) Water test ( water ) ID tag type (on assets) Electronic ID ( eid , on all assets) Other ( other , on all assets) Brand ( brand , on Animal assets) Ear tag ( ear_tag , on Animal assets) Leg band ( leg_band , on Animal assets) Tattoo ( tattoo , on Animal assets) These options are provided as configuration entities by farmOS modules in the form of YAML files. Existing options can be overridden or removed by editing/deleting the entities in the active configuration of the site. ( Warning changing core types runs the risk of conflicting with future farmOS updates). Examples: \u00b6 Flag \u00b6 An \"Organic\" flag can be provided by a module named my_module by creating a file called farm_flag.flag.organic.yml in my_module/config/install : langcode: en status: true dependencies: enforced: module: - my_module id: monitor label: Monitor The most important parts are the id , which is a unique machine name for the flag, and label , which is the human readable/translatable label that will be shown in the select field and other parts of the UI. The langcode and status and dependencies are standard configuration entity properties. By putting the module's name in \"enforced modules\" it will ensure that the flag is removed when the module is uninstalled. Land type \u00b6 The \"Land\" module in farmOS provides a \"Field\" type like this: land/config/install/farm_land.land_type.field.yml langcode: en status: true dependencies: enforced: module: - farm_land id: field label: Field Structure type \u00b6 The \"Structure\" module in farmOS provides a \"Building\" type like this: structure/config/install/farm_structure.structure_type.building.yml langcode: en status: true dependencies: enforced: module: - farm_structure id: building label: Building Lab test type \u00b6 The \"Lab test\" module in farmOS provides a \"Soil test\" type like this: lab_test/config/install/farm_lab_test.lab_test_type.soil.yml langcode: en status: true dependencies: enforced: module: - farm_lab_test id: soil label: Soil test ID tag type \u00b6 ID tag types are similar to Flags, in that they have an id and label , but they also have an additional property: bundle . This allows the tag type to be limited to certain types of assets. For example, an \"Ear tag\" type, provided by the \"Animal asset\" module, only applies to \"Animal\" assets: animal/config/install/farm_flag.flag.ear_tag.yml langcode: en status: true dependencies: enforced: module: - farm_animal - farm_id_tag id: ear_tag label: Ear tag bundles: - animal If you want the tag type to apply to all assets, set bundles: null . (or can it just be omitted?)","title":"Fields"},{"location":"development/module/fields/#fields","text":"","title":"Fields"},{"location":"development/module/fields/#adding-fields","text":"A module may add additional fields to assets, logs, and other entity types in farmOS. The following documents how to add fields to existing entity types. See Entity types to understand how to create new asset, log, and plan types with custom fields on them.","title":"Adding fields"},{"location":"development/module/fields/#base-fields","text":"If the field should be added to all bundles of a given entity type (eg: all log types), then they should be added as \"base fields\" via hook_entity_base_field_info() . A farm_field.factory helper service is provided to make this easier: <?php use Drupal\\Core\\Entity\\EntityTypeInterface; /** * Implements hook_entity_base_field_info(). */ function mymodule_entity_base_field_info(EntityTypeInterface $entity_type) { $fields = []; // Add a new string field to Log entities. if ($entity_type->id() == 'log') { $options = [ 'type' => 'string', 'label' => t('My new field'), 'description' => t('My field description.'), 'weight' => [ 'form' => 10, 'view' => 10, ], ]; $fields['myfield'] = \\Drupal::service('farm_field.factory')->baseFieldDefinition($options); } return $fields; }","title":"Base fields"},{"location":"development/module/fields/#bundle-fields","text":"If the field should only be added to a single bundle (eg: only \"Input\" logs), then they should be added as \"bundle fields\" via hook_farm_entity_bundle_field_info() * * Note that this is a custom hook provided by farmOS, which may be deprecated in favor of a core Drupal hook in the future. See core issue: https://www.drupal.org/node/2346347 The format for bundle field definitions is identical to base field definitions (above), but the bundleFieldDefinition() method must be used instead of baseFieldDefinition() . <?php use Drupal\\Core\\Entity\\EntityTypeInterface; /** * Implements hook_farm_entity_bundle_field_info(). */ function mymodule_farm_entity_bundle_field_info(EntityTypeInterface $entity_type, $bundle) { $fields = []; // Add a new string field to Input Logs. if ($entity_type->id() == 'log' && $bundle == 'input') { $options = [ 'type' => 'string', 'label' => t('My new field'), 'description' => t('My field description.'), 'weight' => [ 'form' => 10, 'view' => 10, ], ]; $fields['myfield'] = \\Drupal::service('farm_field.factory')->bundleFieldDefinition($options); } return $fields; }","title":"Bundle fields"},{"location":"development/module/fields/#select-options","text":"Certain fields on assets and logs include a list of options to select from. These include: Flags (on assets and logs) Monitor ( monitor ) Needs review ( needs_review ) Priority ( priority ) Land types (on Land assets) Property ( property ) Field ( field ) Bed ( bed ) Paddock ( paddock ) Landmark ( landmark ) Other ( other ) Structure types (on Structure assets) Building ( building ) Greenhouse ( greenhouse ) Lab test type (on Lab test logs) Soil test ( soil ) Water test ( water ) ID tag type (on assets) Electronic ID ( eid , on all assets) Other ( other , on all assets) Brand ( brand , on Animal assets) Ear tag ( ear_tag , on Animal assets) Leg band ( leg_band , on Animal assets) Tattoo ( tattoo , on Animal assets) These options are provided as configuration entities by farmOS modules in the form of YAML files. Existing options can be overridden or removed by editing/deleting the entities in the active configuration of the site. ( Warning changing core types runs the risk of conflicting with future farmOS updates).","title":"Select options"},{"location":"development/module/fields/#examples","text":"","title":"Examples:"},{"location":"development/module/fields/#flag","text":"An \"Organic\" flag can be provided by a module named my_module by creating a file called farm_flag.flag.organic.yml in my_module/config/install : langcode: en status: true dependencies: enforced: module: - my_module id: monitor label: Monitor The most important parts are the id , which is a unique machine name for the flag, and label , which is the human readable/translatable label that will be shown in the select field and other parts of the UI. The langcode and status and dependencies are standard configuration entity properties. By putting the module's name in \"enforced modules\" it will ensure that the flag is removed when the module is uninstalled.","title":"Flag"},{"location":"development/module/fields/#land-type","text":"The \"Land\" module in farmOS provides a \"Field\" type like this: land/config/install/farm_land.land_type.field.yml langcode: en status: true dependencies: enforced: module: - farm_land id: field label: Field","title":"Land type"},{"location":"development/module/fields/#structure-type","text":"The \"Structure\" module in farmOS provides a \"Building\" type like this: structure/config/install/farm_structure.structure_type.building.yml langcode: en status: true dependencies: enforced: module: - farm_structure id: building label: Building","title":"Structure type"},{"location":"development/module/fields/#lab-test-type","text":"The \"Lab test\" module in farmOS provides a \"Soil test\" type like this: lab_test/config/install/farm_lab_test.lab_test_type.soil.yml langcode: en status: true dependencies: enforced: module: - farm_lab_test id: soil label: Soil test","title":"Lab test type"},{"location":"development/module/fields/#id-tag-type","text":"ID tag types are similar to Flags, in that they have an id and label , but they also have an additional property: bundle . This allows the tag type to be limited to certain types of assets. For example, an \"Ear tag\" type, provided by the \"Animal asset\" module, only applies to \"Animal\" assets: animal/config/install/farm_flag.flag.ear_tag.yml langcode: en status: true dependencies: enforced: module: - farm_animal - farm_id_tag id: ear_tag label: Ear tag bundles: - animal If you want the tag type to apply to all assets, set bundles: null . (or can it just be omitted?)","title":"ID tag type"},{"location":"development/module/oauth/","text":"OAuth \u00b6 The Simple OAuth module is used to provide an OAuth2 standard authorization server. For documentation on using and authenticating with the farmOS API see API . Providing OAuth Clients \u00b6 OAuth clients are modeled as \"Consumer\" entities (provided by the Consumers module. The farm_api module provides a default client with client_id = farm . This can be used for general usage of the API, but comes with limitations. To create a third party integration with farmOS a consumer entity must be created that identifies the integration and configures the OAuth Client authorization behavior. Scopes \u00b6 OAuth scopes define different levels of permission. OAuth clients are configured with the scopes needed for the purposes of a specific integration. With consumers, these scopes are implemented as Drupal Roles. This means that OAuth clients interacting with farmOS over the API use the same permission system as Users normally using the site. Client Configuration \u00b6 Standard Consumer configuration: consumer.label - A label used to identify the third party integration. consumer.client_id - An optional client_id machine name to identify the consumer. The simple_oauth module uses a UUID by default, but a machine name makes it easier to identify clients across multiple farmOS servers. consumer.secret - A client_secret used to secure the OAuth client. consumer.confidential - A boolean indicating whether the client secret needs to be validated. Most farmOS third party integrations will disable this. Otherwise the same client_secret must be configured on all farmOS servers, or the third party must keep track of a different secret for each server. This challenge is due to the nature of farmOS being a self-hosted application. consumer.user_id - When no specific user is authenticated Drupal will use this user as the author of all the actions made by this consumer. This is only the case during the Client Credentials authorization flow. consumer.redirect_uri - The URI this client will redirect to when needed. This is used with the Authorization Code authorization flow. consumer.third_party - Enable if the Consumer represents a third party. Users will skip the \"grant\" step of the authorization flow for first party consumers only. farmOS extends the consumers and simple_oauth modules to provide additional authorization options on consumer entities. These additional options make it possible to support different third party integration use cases via the same OAuth Authorization server. They can be configured via the UI or when creating a consumer entity programmatically. Authorization options (all are disabled by default): consumer.grant_user_access - Always grant the authorizing user's access to this consumer. This is how the farmOS Field Kit consumer is configured. If this is the only option enabled, then the consumer will only be granted the roles the user has access to. consumer.limit_requested_access - Only grant this consumer the scopes requested during authorization. By default, all scopes configured with the consumer will be granted during authorization. This allows users to select which scopes they want to grant the third party during authorization. consumer.limit_user_access - Never grant the consumer more access than the authorizing user. It is possible that clients will be configured with different roles than the user that authorizes access to a third party. There are times that this may be intentional, but this setting ensures that consumers will not be granted more access than the authorizing user.","title":"OAuth"},{"location":"development/module/oauth/#oauth","text":"The Simple OAuth module is used to provide an OAuth2 standard authorization server. For documentation on using and authenticating with the farmOS API see API .","title":"OAuth"},{"location":"development/module/oauth/#providing-oauth-clients","text":"OAuth clients are modeled as \"Consumer\" entities (provided by the Consumers module. The farm_api module provides a default client with client_id = farm . This can be used for general usage of the API, but comes with limitations. To create a third party integration with farmOS a consumer entity must be created that identifies the integration and configures the OAuth Client authorization behavior.","title":"Providing OAuth Clients"},{"location":"development/module/oauth/#scopes","text":"OAuth scopes define different levels of permission. OAuth clients are configured with the scopes needed for the purposes of a specific integration. With consumers, these scopes are implemented as Drupal Roles. This means that OAuth clients interacting with farmOS over the API use the same permission system as Users normally using the site.","title":"Scopes"},{"location":"development/module/oauth/#client-configuration","text":"Standard Consumer configuration: consumer.label - A label used to identify the third party integration. consumer.client_id - An optional client_id machine name to identify the consumer. The simple_oauth module uses a UUID by default, but a machine name makes it easier to identify clients across multiple farmOS servers. consumer.secret - A client_secret used to secure the OAuth client. consumer.confidential - A boolean indicating whether the client secret needs to be validated. Most farmOS third party integrations will disable this. Otherwise the same client_secret must be configured on all farmOS servers, or the third party must keep track of a different secret for each server. This challenge is due to the nature of farmOS being a self-hosted application. consumer.user_id - When no specific user is authenticated Drupal will use this user as the author of all the actions made by this consumer. This is only the case during the Client Credentials authorization flow. consumer.redirect_uri - The URI this client will redirect to when needed. This is used with the Authorization Code authorization flow. consumer.third_party - Enable if the Consumer represents a third party. Users will skip the \"grant\" step of the authorization flow for first party consumers only. farmOS extends the consumers and simple_oauth modules to provide additional authorization options on consumer entities. These additional options make it possible to support different third party integration use cases via the same OAuth Authorization server. They can be configured via the UI or when creating a consumer entity programmatically. Authorization options (all are disabled by default): consumer.grant_user_access - Always grant the authorizing user's access to this consumer. This is how the farmOS Field Kit consumer is configured. If this is the only option enabled, then the consumer will only be granted the roles the user has access to. consumer.limit_requested_access - Only grant this consumer the scopes requested during authorization. By default, all scopes configured with the consumer will be granted during authorization. This allows users to select which scopes they want to grant the third party during authorization. consumer.limit_user_access - Never grant the consumer more access than the authorizing user. It is possible that clients will be configured with different roles than the user that authorizes access to a third party. There are times that this may be intentional, but this setting ensures that consumers will not be granted more access than the authorizing user.","title":"Client Configuration"},{"location":"development/module/roles/","text":"Roles \u00b6 Roles are groups of permissions that can be assigned to users to grant them granular access to data and features in farmOS. Module developers can define new roles, and specify which permissions they should include. farmOS also builds on top of Drupal's role and permission system to provide a concept of \"Managed Roles\". Managed Roles \u00b6 The farmOS Access module provides methods to create user roles with permissions that are managed for the purposes of farmOS. These roles cannot be modified from the Admin Permissions UI. Instead, these roles allow permissions to be provided by other modules that want to provide sensible defaults for common farmOS roles. Creating a managed role \u00b6 User roles are provided as Drupal Configuration Entities. Managed roles are provided in the same way the only difference being that they include additional third party settings the farmOS Access module uses to build managed permissions. The user.role.*.third_party.farm_acccess schema defines the structure of these settings. access : An optional array of default access permissions. config : Boolean that specifies whether the role should have access to configuration. Only grant this to trusted roles. entity : Access permissions relating to entities. view all : Boolean that specifies the role should have access to view all bundles of all entity types. create all : Boolean that specifies the role should have access to create all bundles of all entity types. update all : Boolean that specifies the role should have access to update all bundles of all entity types. delete all : Boolean that specifies the role should have access to delete all bundles of all entity types. type : Access permissions for specific entity types. {entity_type} : The id of the entity type. eg: log , asset , taxonomy_term , etc. {operation} : The operation to grant bundles of this entity type. Eg: create , view any , view own , delete any , delete own , etc. {bundle} : The id of the entity type bundle or all to grant the operation permission to all bundles of the entity type. Settings used for the Manager role (full access to all entities + access to configuration): user.role.farm_manager.yml # (standard role config goes here) third_party_settings: farm_role: access: config: true entity: view all: true create all: true update all: true delete all: true Example settings to define a \"Harvester\" role with these limitations: View all log entities. Only create harvest logs, update harvest logs, and delete own harvest logs. View all asset entities. Only update planting assets. View, edit and delete any taxonomy_term entity. user.role.farm_harvester.yml # (standard role config goes here) third_party_settings: farm_role: access: entity: view all: true type: log: create: - harvest update any: - harvest delete own: - harvest asset: update any: - planting taxonomy_term: edit: - all delete: - all Providing permissions for managed roles \u00b6 Modules can define sensible permissions to any managed roles. These permissions are provided by creating a ManagedRolePermissions plugin in the module.managed_role_permissions.yml file. The following keys can be provided: default_permissions : A list of permissions that will be added to all managed roles. config_permissions : A list of permissions that will be added to managed roles that have access to configuration ( config: true ). permission_callbacks : A list of callbacks in controller notation that return an array of permissions to add to managed roles. Callbacks are provided a Role object so that permissions can be applied conditionally based on the managed role's settings. As an example, the farm_role module provides the following permissions: farm_role.managed_role_permissions.yml farm_role: default_permissions: - access content - access administration pages - access user profiles - access taxonomy overview config_permissions: - administer taxonomy Permission callbacks \u00b6 Example that adds permissions conditionally based on the role name and settings: Plugin definition: my_module.managed_role_permissions.yml my_module: permission_callbacks: - Drupal\\my_module\\CustomPermissions::permissions Example implementation of a permission_callback : my_module/src/CustomPermissions.php <?php namespace Drupal\\my_module; use Drupal\\user\\RoleInterface; /** * Example custom permission callback. */ class CustomPermissions { /** * Return an array of permission strings that will be added to the role. * * @param \\Drupal\\user\\RoleInterface $role * The role to add permissions to. * * @return array * An array of permission strings. */ public function permissions(RoleInterface $role) { // Array of permissions to return. $perms = []; // Add permissions based on role name. if ($role->id() == 'farm_manager') { $perms = 'my manager permission'; } // Get the farm_role third party settings from the Role entity. $access_settings = $role->getThirdPartySetting('farm_role', 'access'); $entity_settings = $access_settings['entity'] ?: []; // Only add permissions if `update all` and `delete all` are true. if (!empty($entity_settings['update all'] && $entity_settings['delete all'])) { $perms[] = 'recover all permission'; } // Return array of permissions. return $perms; } }","title":"Roles"},{"location":"development/module/roles/#roles","text":"Roles are groups of permissions that can be assigned to users to grant them granular access to data and features in farmOS. Module developers can define new roles, and specify which permissions they should include. farmOS also builds on top of Drupal's role and permission system to provide a concept of \"Managed Roles\".","title":"Roles"},{"location":"development/module/roles/#managed-roles","text":"The farmOS Access module provides methods to create user roles with permissions that are managed for the purposes of farmOS. These roles cannot be modified from the Admin Permissions UI. Instead, these roles allow permissions to be provided by other modules that want to provide sensible defaults for common farmOS roles.","title":"Managed Roles"},{"location":"development/module/roles/#creating-a-managed-role","text":"User roles are provided as Drupal Configuration Entities. Managed roles are provided in the same way the only difference being that they include additional third party settings the farmOS Access module uses to build managed permissions. The user.role.*.third_party.farm_acccess schema defines the structure of these settings. access : An optional array of default access permissions. config : Boolean that specifies whether the role should have access to configuration. Only grant this to trusted roles. entity : Access permissions relating to entities. view all : Boolean that specifies the role should have access to view all bundles of all entity types. create all : Boolean that specifies the role should have access to create all bundles of all entity types. update all : Boolean that specifies the role should have access to update all bundles of all entity types. delete all : Boolean that specifies the role should have access to delete all bundles of all entity types. type : Access permissions for specific entity types. {entity_type} : The id of the entity type. eg: log , asset , taxonomy_term , etc. {operation} : The operation to grant bundles of this entity type. Eg: create , view any , view own , delete any , delete own , etc. {bundle} : The id of the entity type bundle or all to grant the operation permission to all bundles of the entity type. Settings used for the Manager role (full access to all entities + access to configuration): user.role.farm_manager.yml # (standard role config goes here) third_party_settings: farm_role: access: config: true entity: view all: true create all: true update all: true delete all: true Example settings to define a \"Harvester\" role with these limitations: View all log entities. Only create harvest logs, update harvest logs, and delete own harvest logs. View all asset entities. Only update planting assets. View, edit and delete any taxonomy_term entity. user.role.farm_harvester.yml # (standard role config goes here) third_party_settings: farm_role: access: entity: view all: true type: log: create: - harvest update any: - harvest delete own: - harvest asset: update any: - planting taxonomy_term: edit: - all delete: - all","title":"Creating a managed role"},{"location":"development/module/roles/#providing-permissions-for-managed-roles","text":"Modules can define sensible permissions to any managed roles. These permissions are provided by creating a ManagedRolePermissions plugin in the module.managed_role_permissions.yml file. The following keys can be provided: default_permissions : A list of permissions that will be added to all managed roles. config_permissions : A list of permissions that will be added to managed roles that have access to configuration ( config: true ). permission_callbacks : A list of callbacks in controller notation that return an array of permissions to add to managed roles. Callbacks are provided a Role object so that permissions can be applied conditionally based on the managed role's settings. As an example, the farm_role module provides the following permissions: farm_role.managed_role_permissions.yml farm_role: default_permissions: - access content - access administration pages - access user profiles - access taxonomy overview config_permissions: - administer taxonomy","title":"Providing permissions for managed roles"},{"location":"development/module/roles/#permission-callbacks","text":"Example that adds permissions conditionally based on the role name and settings: Plugin definition: my_module.managed_role_permissions.yml my_module: permission_callbacks: - Drupal\\my_module\\CustomPermissions::permissions Example implementation of a permission_callback : my_module/src/CustomPermissions.php <?php namespace Drupal\\my_module; use Drupal\\user\\RoleInterface; /** * Example custom permission callback. */ class CustomPermissions { /** * Return an array of permission strings that will be added to the role. * * @param \\Drupal\\user\\RoleInterface $role * The role to add permissions to. * * @return array * An array of permission strings. */ public function permissions(RoleInterface $role) { // Array of permissions to return. $perms = []; // Add permissions based on role name. if ($role->id() == 'farm_manager') { $perms = 'my manager permission'; } // Get the farm_role third party settings from the Role entity. $access_settings = $role->getThirdPartySetting('farm_role', 'access'); $entity_settings = $access_settings['entity'] ?: []; // Only add permissions if `update all` and `delete all` are true. if (!empty($entity_settings['update all'] && $entity_settings['delete all'])) { $perms[] = 'recover all permission'; } // Return array of permissions. return $perms; } }","title":"Permission callbacks"},{"location":"development/module/updates/","text":"Automated updates \u00b6 farmOS modules may change and evolve over time. If these changes require updates to a farmOS database or configuration, then update logic should be provided so that users of the module can perform the necessary changes automatically when they update to the new version. This logic can be supplied via implementations of hook_update_N() . For more information, see the documentation for Drupal's Update API .","title":"Updates"},{"location":"development/module/updates/#automated-updates","text":"farmOS modules may change and evolve over time. If these changes require updates to a farmOS database or configuration, then update logic should be provided so that users of the module can perform the necessary changes automatically when they update to the new version. This logic can be supplied via implementations of hook_update_N() . For more information, see the documentation for Drupal's Update API .","title":"Automated updates"},{"location":"hosting/","text":"Hosting farmOS \u00b6 farmOS is a web-based application that can be installed and hosted on a web server, much like a website. This allows it to be accessed by multiple people simultaneously, from any device with a web browser and internet connection. Self hosting \u00b6 If you are familiar with hosting database-backed websites, you can install farmOS on your own web server. farmOS is free software , which means you are free to download the code and host it yourself. You are also free to modify and extend it to fit your needs. For more information, including server requirements, refer to Installing farmOS . To understand how to update farmOS when a new version is released, refer to Updating farmOS . Subscription hosting \u00b6 If you are not comfortable hosting and maintaining your own server, subscription hosting allows you to get started with farmOS quickly and easily. Farmier is a subscription hosting service that provides \" farmOS as a service \", including hosting, automatic updates, backups, SSL security, and other features. Farmier was started by the creator of farmOS, and subscriptions help to support the continued development of farmOS. For more information, visit https://farmier.com .","title":"Introduction"},{"location":"hosting/#hosting-farmos","text":"farmOS is a web-based application that can be installed and hosted on a web server, much like a website. This allows it to be accessed by multiple people simultaneously, from any device with a web browser and internet connection.","title":"Hosting farmOS"},{"location":"hosting/#self-hosting","text":"If you are familiar with hosting database-backed websites, you can install farmOS on your own web server. farmOS is free software , which means you are free to download the code and host it yourself. You are also free to modify and extend it to fit your needs. For more information, including server requirements, refer to Installing farmOS . To understand how to update farmOS when a new version is released, refer to Updating farmOS .","title":"Self hosting"},{"location":"hosting/#subscription-hosting","text":"If you are not comfortable hosting and maintaining your own server, subscription hosting allows you to get started with farmOS quickly and easily. Farmier is a subscription hosting service that provides \" farmOS as a service \", including hosting, automatic updates, backups, SSL security, and other features. Farmier was started by the creator of farmOS, and subscriptions help to support the continued development of farmOS. For more information, visit https://farmier.com .","title":"Subscription hosting"},{"location":"hosting/email/","text":"Email configuration \u00b6 farmOS needs to be able to send emails to users. This is used for password reset emails, notifications, etc. Depending on how you have farmOS deployed, there are a few ways to configure your server to allow farmOS to send emails. By default, farmOS will attempt to send emails via an SMTP server installed on the same system. If you have Postfix installed, email should work without any additional configuration, although they will most likely be filtered as spam. This StackOverflow topic provides guidance for avoiding this. Docker \u00b6 The farmOS Docker images do not include an SMTP server, so you will see this error message when farmOS tries to send an email: Unable to send e-mail. Contact the site administrator if the problem persists. There are two potential solutions to this: Install and configure the SMTP module. This is a contributed Drupal module that allows emails to be relayed through a third-party SMTP server. This module is not included with farmOS, but can be downloaded into [farmOS-codebase]/web/sites/all/modules and enabled in https://[farmOS-hostname]/admin/modules . Create your own Docker image which inherits from the farmOS image. This image can install an SMTP server like Postfix, which can be configured to send email directly, or relay it through another SMTP server.","title":"Email"},{"location":"hosting/email/#email-configuration","text":"farmOS needs to be able to send emails to users. This is used for password reset emails, notifications, etc. Depending on how you have farmOS deployed, there are a few ways to configure your server to allow farmOS to send emails. By default, farmOS will attempt to send emails via an SMTP server installed on the same system. If you have Postfix installed, email should work without any additional configuration, although they will most likely be filtered as spam. This StackOverflow topic provides guidance for avoiding this.","title":"Email configuration"},{"location":"hosting/email/#docker","text":"The farmOS Docker images do not include an SMTP server, so you will see this error message when farmOS tries to send an email: Unable to send e-mail. Contact the site administrator if the problem persists. There are two potential solutions to this: Install and configure the SMTP module. This is a contributed Drupal module that allows emails to be relayed through a third-party SMTP server. This module is not included with farmOS, but can be downloaded into [farmOS-codebase]/web/sites/all/modules and enabled in https://[farmOS-hostname]/admin/modules . Create your own Docker image which inherits from the farmOS image. This image can install an SMTP server like Postfix, which can be configured to send email directly, or relay it through another SMTP server.","title":"Docker"},{"location":"hosting/install/","text":"Installing farmOS \u00b6 Server requirements \u00b6 farmOS is based on Drupal , and therefore shares many of the same requirements . Web server \u00b6 In addition to Drupal's basic requirements, farmOS has the following server dependencies. The farmOS Docker images include these. PHP 7+ PHP configuration - The following PHP settings are recommended: memory_limit=256M max_execution_time=240 max_input_time=240 max_input_vars=5000 realpath_cache_size=4096K realpath_cache_ttl=3600 PHP BCMath extension is required for accurate geometric polygon area calculations. GEOS is required by the Bed Generator module. Database server \u00b6 A database server needs to be provisioned that farmOS can connect to. PostgreSQL is recommended. MySQL/MariaDB and SQLite are also supported. This can be installed on the same server as farmOS (either directly or in a Docker container), or it can be on a separate server. SSL \u00b6 Although not strictly a requirement, some features (like the \"Geolocate\" button on maps) will only work over a secure connection. Field Kit requires SSL in order to connect to it. SSL is also recommended if you are using the Sensor Listener module to keep your sensor's private key a secret. A common strategy is to use Nginx as a reverse proxy with SSL termination, which listens on port 443 and forwards to farmOS on port 80. Let's Encrypt is a good option for free SSL certificate issuance, and renewal can be automated via cron. These resources may be helpful: Drupal HTTPS Information Reverse Proxy Forum Post - Includes links to related GitHub issues and examples of how others have configured reverse proxies serving HTTPS. Local HTTPS - Documentation for running an Nginx reverse proxy with self-signed certificates for local farmOS development with HTTPS. API Keys \u00b6 Optional modules are available for adding satellite imagery layers to maps (eg: Mapbox, Google Maps, etc). However, because these layers are hosted by third-party providers, API keys are required to use them. Instructions for obtaining API keys are available via the links below. API keys can be entered into farmOS by going to Settings > Map. Mapbox Google Maps farmOS Codebase \u00b6 There are two supported approaches to deploying the farmOS codebase: Using Docker images. Using packaged releases. Docker is the recommended method of hosting farmOS because it encapsulates the server level dependencies that farmOS needs. farmOS in Docker \u00b6 Official farmOS Docker images are available on Docker Hub: https://hub.docker.com/r/farmos/farmos This allows farmOS to be run in a Docker container with: docker pull farmos/farmos:2.x docker run --rm -p 80:80 -v \"${PWD}/sites:/opt/drupal/web/sites\" farmos/farmos:2.x This will pull the farmOS Docker image, provision a farmOS web server container listening on port 80, and bind-mount a sites directory into the container for persistence of settings and uploaded files. Docker Compose \u00b6 Docker Compose can be used to encapsulate these decisions. An example docker-compose.production.yml configuration file is provided in the farmOS repository's docker directory, with an accompanying README.md . Copy this to a file named docker-compose.yml in the directory you would like to install farmOS and run: docker-compose up -d Persistence \u00b6 All site-specific settings and user-uploaded files are stored in /opt/drupal/web/sites inside the container, so it is important that the contents of this directory be persisted outside of the container. Bind-mounting a directory from the host into the container is the recommended way to achieve this. The docker run command above does this, as well as the example docker-compose.yml provided in the farmOS repository's docker directory. If the sites directory is not persisted, all settings and files will be lost when the container is destroyed, and you will be prompted to install farmOS again when a new container is started. Customizing PHP \u00b6 If customizations to PHP's configuration are required, such as increasing the maximum upload size limit, you can bind-mount a custom PHP settings file into the container. Create a file called php.ini alongside docker-compose.yml : upload_max_filesize = 50M post_max_size = 50M Bind-mount php.ini into the www service in your docker-compose.yml file: volumes: ... - './php.ini:/usr/local/etc/php/conf.d/farmos.ini' Packaged releases \u00b6 An alternative to the Docker-based deployment is to install the farmOS codebase directly on the host server using a packaged release tarball, available from GitHub: github.com/farmOS/farmOS/releases Packaged releases include everything from the /opt/drupal directory in the Docker image. This represents the entire farmOS codebase, pre-built with Composer . Download and unpack the tarball on your web server, and point the document root at the web subdirectory. Installing farmOS \u00b6 Once you have the farmOS codebase deployed, and a database server provisioned, you can proceed with the web-based farmOS installation. Visit the farmOS server's hostname in your browser and follow the steps to install farmOS and optional modules.","title":"Installing"},{"location":"hosting/install/#installing-farmos","text":"","title":"Installing farmOS"},{"location":"hosting/install/#server-requirements","text":"farmOS is based on Drupal , and therefore shares many of the same requirements .","title":"Server requirements"},{"location":"hosting/install/#web-server","text":"In addition to Drupal's basic requirements, farmOS has the following server dependencies. The farmOS Docker images include these. PHP 7+ PHP configuration - The following PHP settings are recommended: memory_limit=256M max_execution_time=240 max_input_time=240 max_input_vars=5000 realpath_cache_size=4096K realpath_cache_ttl=3600 PHP BCMath extension is required for accurate geometric polygon area calculations. GEOS is required by the Bed Generator module.","title":"Web server"},{"location":"hosting/install/#database-server","text":"A database server needs to be provisioned that farmOS can connect to. PostgreSQL is recommended. MySQL/MariaDB and SQLite are also supported. This can be installed on the same server as farmOS (either directly or in a Docker container), or it can be on a separate server.","title":"Database server"},{"location":"hosting/install/#ssl","text":"Although not strictly a requirement, some features (like the \"Geolocate\" button on maps) will only work over a secure connection. Field Kit requires SSL in order to connect to it. SSL is also recommended if you are using the Sensor Listener module to keep your sensor's private key a secret. A common strategy is to use Nginx as a reverse proxy with SSL termination, which listens on port 443 and forwards to farmOS on port 80. Let's Encrypt is a good option for free SSL certificate issuance, and renewal can be automated via cron. These resources may be helpful: Drupal HTTPS Information Reverse Proxy Forum Post - Includes links to related GitHub issues and examples of how others have configured reverse proxies serving HTTPS. Local HTTPS - Documentation for running an Nginx reverse proxy with self-signed certificates for local farmOS development with HTTPS.","title":"SSL"},{"location":"hosting/install/#api-keys","text":"Optional modules are available for adding satellite imagery layers to maps (eg: Mapbox, Google Maps, etc). However, because these layers are hosted by third-party providers, API keys are required to use them. Instructions for obtaining API keys are available via the links below. API keys can be entered into farmOS by going to Settings > Map. Mapbox Google Maps","title":"API Keys"},{"location":"hosting/install/#farmos-codebase","text":"There are two supported approaches to deploying the farmOS codebase: Using Docker images. Using packaged releases. Docker is the recommended method of hosting farmOS because it encapsulates the server level dependencies that farmOS needs.","title":"farmOS Codebase"},{"location":"hosting/install/#farmos-in-docker","text":"Official farmOS Docker images are available on Docker Hub: https://hub.docker.com/r/farmos/farmos This allows farmOS to be run in a Docker container with: docker pull farmos/farmos:2.x docker run --rm -p 80:80 -v \"${PWD}/sites:/opt/drupal/web/sites\" farmos/farmos:2.x This will pull the farmOS Docker image, provision a farmOS web server container listening on port 80, and bind-mount a sites directory into the container for persistence of settings and uploaded files.","title":"farmOS in Docker"},{"location":"hosting/install/#docker-compose","text":"Docker Compose can be used to encapsulate these decisions. An example docker-compose.production.yml configuration file is provided in the farmOS repository's docker directory, with an accompanying README.md . Copy this to a file named docker-compose.yml in the directory you would like to install farmOS and run: docker-compose up -d","title":"Docker Compose"},{"location":"hosting/install/#persistence","text":"All site-specific settings and user-uploaded files are stored in /opt/drupal/web/sites inside the container, so it is important that the contents of this directory be persisted outside of the container. Bind-mounting a directory from the host into the container is the recommended way to achieve this. The docker run command above does this, as well as the example docker-compose.yml provided in the farmOS repository's docker directory. If the sites directory is not persisted, all settings and files will be lost when the container is destroyed, and you will be prompted to install farmOS again when a new container is started.","title":"Persistence"},{"location":"hosting/install/#customizing-php","text":"If customizations to PHP's configuration are required, such as increasing the maximum upload size limit, you can bind-mount a custom PHP settings file into the container. Create a file called php.ini alongside docker-compose.yml : upload_max_filesize = 50M post_max_size = 50M Bind-mount php.ini into the www service in your docker-compose.yml file: volumes: ... - './php.ini:/usr/local/etc/php/conf.d/farmos.ini'","title":"Customizing PHP"},{"location":"hosting/install/#packaged-releases","text":"An alternative to the Docker-based deployment is to install the farmOS codebase directly on the host server using a packaged release tarball, available from GitHub: github.com/farmOS/farmOS/releases Packaged releases include everything from the /opt/drupal directory in the Docker image. This represents the entire farmOS codebase, pre-built with Composer . Download and unpack the tarball on your web server, and point the document root at the web subdirectory.","title":"Packaged releases"},{"location":"hosting/install/#installing-farmos_1","text":"Once you have the farmOS codebase deployed, and a database server provisioned, you can proceed with the web-based farmOS installation. Visit the farmOS server's hostname in your browser and follow the steps to install farmOS and optional modules.","title":"Installing farmOS"},{"location":"hosting/migration/","text":"Migrating from farmOS 1.x to 2.x \u00b6 The upgrade path from farmOS 1.x to 2.x is performed via a database migration. farmOS 2.x includes a farmOS Migrate module that leverage's Drupal core's Migrate API to provide migrations for each asset type, log type, etc. These migrations are defined in YML configuration files included with the farmOS Migrate module. Important considerations \u00b6 Do not migrate into a farmOS 2.x instance that already has records. This is to ensure that the internal auto-incrementing IDs of records are maintained. Execute the migrations in the exact order they are shown below. It is especially important that all assets are migrated before any areas, because areas are converted to assets during the migration, which can cause ID conflicts/collisions. See Issue #3203228 Uploaded photos/files must be copied to the destination filesystem before migrating. See Migrating files below. See Limitations below. Running the migration \u00b6 Follow the steps below to migrate your farmOS 1.x data to farmOS 2.x: Install farmOS 2.x. Install the farmOS modules you intend to use (this will determine what data is migrated). Add farmOS 1.x database connection info to settings.php : $databases['migrate']['default'] = [ 'database' => 'my_farmos_1x_db', 'username' => 'my-db-username', 'password' => 'my-db-password', 'prefix' => '', 'host' => 'localhost', 'port' => '3306', 'namespace' => 'Drupal\\\\Core\\\\Database\\\\Driver\\\\mysql', 'driver' => 'mysql', ]; Copy user-uploaded files to the new directory (see Migrating files below). Install the farmOS Migrate ( farm_migrate ) module. Run the farmOS 1.x Migrations via Drush (in this order): drush migrate:import --group=farm_migrate_config drush migrate:import --group=farm_migrate_role drush migrate:import --group=farm_migrate_user drush migrate:import --group=farm_migrate_file drush migrate:import --group=farm_migrate_taxonomy drush migrate:import --group=farm_migrate_asset drush migrate:import --group=farm_migrate_area drush migrate:import --group=farm_migrate_quantity drush migrate:import --group=farm_migrate_log drush migrate:import --group=farm_migrate_plan Confirm that all the above migrations were successful before running the final migration, which focuses only on populating the \"Parents\" field of assets. This migration cannot be rolled back (see Issue #3189740 ): drush migrate:import --group=farm_migrate_reference To view the status of all farmOS 1.x migrations: drush migrate:status --tag=\"farmOS 1.x\" After all migrations are complete, perform a thorough examination of data to confirm that nothing is missing or incorrect. The original 1.x database will not be touched during the migration, so if issues are discovered it can continue to be used as the canonical farmOS database until further testing and debugging can be performed. See Troubleshooting below for known issues. Please open bug reports in the farmOS issue queue if new issues are discovered. Migrating files \u00b6 farmOS allows files to be uploaded/attached to records. In order to migrate these files, they need to be copied into new site's files/private directories. The farmOS migration code will look for files in the following locations: Public files: public://migrate Private files: private://migrate The public:// and private:// prefixes map to the \"Public file system path\" and \"Private file system path\" configured in farmOS 1.x and 2.x at: /admin/config/media/file-system . This may vary for each installation. For example, if you have farmOS 1.x installed in /var/www/farmOS_1.x and farmOS 2.x in /var/www/farmOS_2.x , and both are configured to use sites/default/files for public files, and sites/default/private for private files, then copy the files as follows: cp -rp /var/www/farmOS_1.x/sites/default/files /var/www/farmOS_2.x/sites/default/files/migrate cp -rp /var/www/farmOS_1.x/sites/default/private/files /var/www/farmOS_2.x/sites/default/private/files/migrate The farmOS migration code will automatically move files from files/migrate/* to files/* . Only the files that it finds in the {file_managed} table will be moved, leaving behind various temporary files in the migrate directory that are no longer needed after the migration. This migrate directory can be deleted after the migration, once it has been confirmed that everything was migrated successfully. Limitations \u00b6 The farmOS migration code is designed to migrate a default farmOS 1.x database to 2.x. If any customizations have been made on top of the defaults, they will not be migrated. This includes (but is not limited to): Custom asset, entity, taxonomies, and log types Custom fields Custom roles If you maintain a contrib/custom module for farmOS 1.x, it is your responsibility to update the modules for 2.x and provide migration logic. Troubleshooting \u00b6 If an error occurs during migration, the status of the broken migration may be stuck as \"Importing\". In order to rerun the migration, first reset the status and then roll back the migration. Replace [migration_id] with ID of the migration that is stuck. drush migrate:reset-status [migration_id] drush migrate:rollback [migration_id] Movement logs \u00b6 farmOS 2.x changes the way asset movements are described via logs. There is a single \"Location reference\" and \"Geometry\" field on logs now, as opposed to the separate \"Move to\" and \"Movement geometry\" fields that existed in 1.x. The migration will use the movement area references and geometry if they are present, and will automatically mark the log as a movement. However, if the log has additional area references and geometry data, then the migration logic will detect the conflict and one of the following errors will be thrown: Log 123 has both area references and movement area references. Log 123 has both a geometry and a movement geometry. If these errors are encountered, the migration will halt and can not be completed until either: the logs in the old database are cleaned up, or the migration script is explicitly allowed to overwrite non-movement area references and geometry Manual clean up involves reviewing the logs that cause errors in the old database, deleting the \"Areas\" and \"Geometry\" fields (or copying them into the \"Move to\" and \"Movement geometry\" fields), and retrying the migration. In some cases it may make sense to split the log into two separate logs, in order to retain information. Alternatively, the migration script can be allowed to automatically overwrite the \"Areas\" and \"Geometry\" data from the log, and only keep the \"Move to\" and \"Movement geometry\" data. This can be configured by adding the following line to settings.php : $settings['farm_migrate_allow_movement_overwrite'] = TRUE; Beware that this may result in loss of data/context if the separate fields were being used intentionally. It is recommended that logs be reviewed manually to understand whether or not the data is needed. After running the migration with this setting, warnings for each log will be stored, and can be viewed with: drush migrate:messages [migration_id] Quantities \u00b6 The farmOS 2.x migration creates all Quantity entities before it creates the Log entities that reference them. This means that it is possible to end up with orphaned quantities, if for instance you do not migrate all of your log types from farmOS 1.x. There is no built-in way to clean these up currently, so it is recommended that all log types be migrated.","title":"1.x Migration"},{"location":"hosting/migration/#migrating-from-farmos-1x-to-2x","text":"The upgrade path from farmOS 1.x to 2.x is performed via a database migration. farmOS 2.x includes a farmOS Migrate module that leverage's Drupal core's Migrate API to provide migrations for each asset type, log type, etc. These migrations are defined in YML configuration files included with the farmOS Migrate module.","title":"Migrating from farmOS 1.x to 2.x"},{"location":"hosting/migration/#important-considerations","text":"Do not migrate into a farmOS 2.x instance that already has records. This is to ensure that the internal auto-incrementing IDs of records are maintained. Execute the migrations in the exact order they are shown below. It is especially important that all assets are migrated before any areas, because areas are converted to assets during the migration, which can cause ID conflicts/collisions. See Issue #3203228 Uploaded photos/files must be copied to the destination filesystem before migrating. See Migrating files below. See Limitations below.","title":"Important considerations"},{"location":"hosting/migration/#running-the-migration","text":"Follow the steps below to migrate your farmOS 1.x data to farmOS 2.x: Install farmOS 2.x. Install the farmOS modules you intend to use (this will determine what data is migrated). Add farmOS 1.x database connection info to settings.php : $databases['migrate']['default'] = [ 'database' => 'my_farmos_1x_db', 'username' => 'my-db-username', 'password' => 'my-db-password', 'prefix' => '', 'host' => 'localhost', 'port' => '3306', 'namespace' => 'Drupal\\\\Core\\\\Database\\\\Driver\\\\mysql', 'driver' => 'mysql', ]; Copy user-uploaded files to the new directory (see Migrating files below). Install the farmOS Migrate ( farm_migrate ) module. Run the farmOS 1.x Migrations via Drush (in this order): drush migrate:import --group=farm_migrate_config drush migrate:import --group=farm_migrate_role drush migrate:import --group=farm_migrate_user drush migrate:import --group=farm_migrate_file drush migrate:import --group=farm_migrate_taxonomy drush migrate:import --group=farm_migrate_asset drush migrate:import --group=farm_migrate_area drush migrate:import --group=farm_migrate_quantity drush migrate:import --group=farm_migrate_log drush migrate:import --group=farm_migrate_plan Confirm that all the above migrations were successful before running the final migration, which focuses only on populating the \"Parents\" field of assets. This migration cannot be rolled back (see Issue #3189740 ): drush migrate:import --group=farm_migrate_reference To view the status of all farmOS 1.x migrations: drush migrate:status --tag=\"farmOS 1.x\" After all migrations are complete, perform a thorough examination of data to confirm that nothing is missing or incorrect. The original 1.x database will not be touched during the migration, so if issues are discovered it can continue to be used as the canonical farmOS database until further testing and debugging can be performed. See Troubleshooting below for known issues. Please open bug reports in the farmOS issue queue if new issues are discovered.","title":"Running the migration"},{"location":"hosting/migration/#migrating-files","text":"farmOS allows files to be uploaded/attached to records. In order to migrate these files, they need to be copied into new site's files/private directories. The farmOS migration code will look for files in the following locations: Public files: public://migrate Private files: private://migrate The public:// and private:// prefixes map to the \"Public file system path\" and \"Private file system path\" configured in farmOS 1.x and 2.x at: /admin/config/media/file-system . This may vary for each installation. For example, if you have farmOS 1.x installed in /var/www/farmOS_1.x and farmOS 2.x in /var/www/farmOS_2.x , and both are configured to use sites/default/files for public files, and sites/default/private for private files, then copy the files as follows: cp -rp /var/www/farmOS_1.x/sites/default/files /var/www/farmOS_2.x/sites/default/files/migrate cp -rp /var/www/farmOS_1.x/sites/default/private/files /var/www/farmOS_2.x/sites/default/private/files/migrate The farmOS migration code will automatically move files from files/migrate/* to files/* . Only the files that it finds in the {file_managed} table will be moved, leaving behind various temporary files in the migrate directory that are no longer needed after the migration. This migrate directory can be deleted after the migration, once it has been confirmed that everything was migrated successfully.","title":"Migrating files"},{"location":"hosting/migration/#limitations","text":"The farmOS migration code is designed to migrate a default farmOS 1.x database to 2.x. If any customizations have been made on top of the defaults, they will not be migrated. This includes (but is not limited to): Custom asset, entity, taxonomies, and log types Custom fields Custom roles If you maintain a contrib/custom module for farmOS 1.x, it is your responsibility to update the modules for 2.x and provide migration logic.","title":"Limitations"},{"location":"hosting/migration/#troubleshooting","text":"If an error occurs during migration, the status of the broken migration may be stuck as \"Importing\". In order to rerun the migration, first reset the status and then roll back the migration. Replace [migration_id] with ID of the migration that is stuck. drush migrate:reset-status [migration_id] drush migrate:rollback [migration_id]","title":"Troubleshooting"},{"location":"hosting/migration/#movement-logs","text":"farmOS 2.x changes the way asset movements are described via logs. There is a single \"Location reference\" and \"Geometry\" field on logs now, as opposed to the separate \"Move to\" and \"Movement geometry\" fields that existed in 1.x. The migration will use the movement area references and geometry if they are present, and will automatically mark the log as a movement. However, if the log has additional area references and geometry data, then the migration logic will detect the conflict and one of the following errors will be thrown: Log 123 has both area references and movement area references. Log 123 has both a geometry and a movement geometry. If these errors are encountered, the migration will halt and can not be completed until either: the logs in the old database are cleaned up, or the migration script is explicitly allowed to overwrite non-movement area references and geometry Manual clean up involves reviewing the logs that cause errors in the old database, deleting the \"Areas\" and \"Geometry\" fields (or copying them into the \"Move to\" and \"Movement geometry\" fields), and retrying the migration. In some cases it may make sense to split the log into two separate logs, in order to retain information. Alternatively, the migration script can be allowed to automatically overwrite the \"Areas\" and \"Geometry\" data from the log, and only keep the \"Move to\" and \"Movement geometry\" data. This can be configured by adding the following line to settings.php : $settings['farm_migrate_allow_movement_overwrite'] = TRUE; Beware that this may result in loss of data/context if the separate fields were being used intentionally. It is recommended that logs be reviewed manually to understand whether or not the data is needed. After running the migration with this setting, warnings for each log will be stored, and can be viewed with: drush migrate:messages [migration_id]","title":"Movement logs"},{"location":"hosting/migration/#quantities","text":"The farmOS 2.x migration creates all Quantity entities before it creates the Log entities that reference them. This means that it is possible to end up with orphaned quantities, if for instance you do not migrate all of your log types from farmOS 1.x. There is no built-in way to clean these up currently, so it is recommended that all log types be migrated.","title":"Quantities"},{"location":"hosting/update/","text":"Updating farmOS \u00b6 ALWAYS BACKUP YOUR DATABASE, CODE, AND FILES BEFORE ATTEMPTING AN UPDATE! New versions of farmOS are released on a regular basis, and it's important to stay up-to-date so that you can receive new features, bug fixes, and security patches when they become available. Update procedure \u00b6 Backup your database and files! Always do this before updating. Be ready and able to roll-back in the event that something goes wrong. Typically this can be done by creating a database dump and a tarball of your web/sites directory. If you are using Docker, be sure you can roll back to the previous image version. If you are using packaged releases, be sure you also keep a copy of the old farmOS codebase before updating. Update the farmOS codebase. This will depend on how you have deployed farmOS. See Updating via Docker or Updating via packaged releases below for specific instructions. Run automated updates. Navigate to https://[hostname]/update.php in your browser and follow the steps to run automated updates. It is important to do this before using the new version of farmOS to ensure that any necessary changes to the database or configuration are made. Updating via Docker \u00b6 If you have deployed farmOS via Docker you can update to a new version of farmOS by pulling the new Docker image version: docker pull farmos/farmos:[version] This can also be done by updating your docker-compose.yml file if you are using Docker Compose and restarting your containers. Assuming that /opt/drupal/web/sites is the only directory persisted outside of the container, this will update the farmOS codebase, which is located in /opt/drupal within the container. See Persistence for more information. Updating via packaged releases \u00b6 If you have deployed farmOS via packaged releases you can update to a new version of farmOS by downloading the new release tarball and unpacking it in place of the old codebase, replacing everything except the web/sites directory. Be sure to replace (not merge ) all files and directories. Do not overwrite the web/sites directory, because it contains all your site-specific settings and uploaded files. Maintenance mode \u00b6 Optionally, you may put farmOS into \"maintenance mode\" to prevent users from accessing it during the update process. Navigate to https://[hostname]/admin/config/development/maintenance in your browser, enable maintenance mode, perform the update, confirm the new version works, then disable maintenance mode. If you are the only user of farmOS then this is not necessary, but be sure to run update.php before using the new version. Drush \u00b6 An alternative to running the automated updates by visiting update.php in your browser is to use the command-line tool Drush . The Drush command for running updates is: drush updb If you are running farmOS in Docker with the standard Docker Compose configuration, you can run this command inside the container with: docker-compose exec www drush updb Security releases \u00b6 When there are security updates released for farmOS dependency modules, you may see the following message: There is a security update available for your version of Drupal. To ensure the security of your server, you should update immediately! See the available updates page for more information. The farmOS maintainers will update these dependencies in the development branch of farmOS as soon as possible, and if the vulnerabilities affect farmOS directly a new version will be tagged and released. Many vulnerabilities are mitigated by the fact that farmOS is only accessible to users with a login. In those cases the maintainers may deem a release unnecessary. This message can disabled by uninstalling the \"Update Manager\" module.","title":"Updating"},{"location":"hosting/update/#updating-farmos","text":"ALWAYS BACKUP YOUR DATABASE, CODE, AND FILES BEFORE ATTEMPTING AN UPDATE! New versions of farmOS are released on a regular basis, and it's important to stay up-to-date so that you can receive new features, bug fixes, and security patches when they become available.","title":"Updating farmOS"},{"location":"hosting/update/#update-procedure","text":"Backup your database and files! Always do this before updating. Be ready and able to roll-back in the event that something goes wrong. Typically this can be done by creating a database dump and a tarball of your web/sites directory. If you are using Docker, be sure you can roll back to the previous image version. If you are using packaged releases, be sure you also keep a copy of the old farmOS codebase before updating. Update the farmOS codebase. This will depend on how you have deployed farmOS. See Updating via Docker or Updating via packaged releases below for specific instructions. Run automated updates. Navigate to https://[hostname]/update.php in your browser and follow the steps to run automated updates. It is important to do this before using the new version of farmOS to ensure that any necessary changes to the database or configuration are made.","title":"Update procedure"},{"location":"hosting/update/#updating-via-docker","text":"If you have deployed farmOS via Docker you can update to a new version of farmOS by pulling the new Docker image version: docker pull farmos/farmos:[version] This can also be done by updating your docker-compose.yml file if you are using Docker Compose and restarting your containers. Assuming that /opt/drupal/web/sites is the only directory persisted outside of the container, this will update the farmOS codebase, which is located in /opt/drupal within the container. See Persistence for more information.","title":"Updating via Docker"},{"location":"hosting/update/#updating-via-packaged-releases","text":"If you have deployed farmOS via packaged releases you can update to a new version of farmOS by downloading the new release tarball and unpacking it in place of the old codebase, replacing everything except the web/sites directory. Be sure to replace (not merge ) all files and directories. Do not overwrite the web/sites directory, because it contains all your site-specific settings and uploaded files.","title":"Updating via packaged releases"},{"location":"hosting/update/#maintenance-mode","text":"Optionally, you may put farmOS into \"maintenance mode\" to prevent users from accessing it during the update process. Navigate to https://[hostname]/admin/config/development/maintenance in your browser, enable maintenance mode, perform the update, confirm the new version works, then disable maintenance mode. If you are the only user of farmOS then this is not necessary, but be sure to run update.php before using the new version.","title":"Maintenance mode"},{"location":"hosting/update/#drush","text":"An alternative to running the automated updates by visiting update.php in your browser is to use the command-line tool Drush . The Drush command for running updates is: drush updb If you are running farmOS in Docker with the standard Docker Compose configuration, you can run this command inside the container with: docker-compose exec www drush updb","title":"Drush"},{"location":"hosting/update/#security-releases","text":"When there are security updates released for farmOS dependency modules, you may see the following message: There is a security update available for your version of Drupal. To ensure the security of your server, you should update immediately! See the available updates page for more information. The farmOS maintainers will update these dependencies in the development branch of farmOS as soon as possible, and if the vulnerabilities affect farmOS directly a new version will be tagged and released. Many vulnerabilities are mitigated by the fact that farmOS is only accessible to users with a login. In those cases the maintainers may deem a release unnecessary. This message can disabled by uninstalling the \"Update Manager\" module.","title":"Security releases"}]}